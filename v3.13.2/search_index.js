var documenterSearchIndex = {"docs":
[{"location":"lib/helpers/#lib-helpers","page":"Helper utils","title":"Helper utilities","text":"","category":"section"},{"location":"lib/helpers/","page":"Helper utils","title":"Helper utils","text":"ReactiveMP implements various structures/functions/methods as \"helper\" structures that might be useful in various contexts.","category":"page"},{"location":"lib/helpers/#lib-helpers-skip-index-iterator","page":"Helper utils","title":"SkipIndexIterator","text":"","category":"section"},{"location":"lib/helpers/","page":"Helper utils","title":"Helper utils","text":"ReactiveMP.SkipIndexIterator\nReactiveMP.skipindex","category":"page"},{"location":"lib/helpers/#ReactiveMP.SkipIndexIterator","page":"Helper utils","title":"ReactiveMP.SkipIndexIterator","text":"SkipIndexIterator\n\nA special type of iterator that simply iterates over internal iterator, but skips index skip.\n\nArguments\n\niterator: internal iterator\nskip: index to skip (integer)\n\nSee also: skipindex\n\n\n\n\n\n","category":"type"},{"location":"lib/helpers/#ReactiveMP.skipindex","page":"Helper utils","title":"ReactiveMP.skipindex","text":"skipindex(iterator, skip)\n\nCreation operator for SkipIndexIterator.\n\njulia> s = ReactiveMP.skipindex(1:3, 2)\n2-element ReactiveMP.SkipIndexIterator{Int64, UnitRange{Int64}}:\n 1\n 3\n\njulia> collect(s)\n2-element Vector{Int64}:\n 1\n 3\n\nSee also: SkipIndexIterator\n\n\n\n\n\n","category":"function"},{"location":"lib/helpers/#lib-helpers-functional-index","page":"Helper utils","title":"FunctionalIndex","text":"","category":"section"},{"location":"lib/helpers/","page":"Helper utils","title":"Helper utils","text":"ReactiveMP.FunctionalIndex","category":"page"},{"location":"lib/helpers/#ReactiveMP.FunctionalIndex","page":"Helper utils","title":"ReactiveMP.FunctionalIndex","text":"FunctionalIndex\n\nA special type of an index that represents a function that can be used only in pair with a collection.  An example of a FunctionalIndex can be firstindex or lastindex, but more complex use cases are possible too,  e.g. firstindex + 1. Important part of the implementation is that the resulting structure is isbitstype(...) = true, that allows to store it in parametric type as valtype.\n\nOne use case for this structure is to dispatch on and to replace begin or end (or more complex use cases, e.g. begin + 1) markers in constraints specification language.\n\n\n\n\n\n","category":"type"},{"location":"lib/rules/rules/#lib-rules","page":"Message update rules","title":"Rules implementation","text":"","category":"section"},{"location":"lib/rules/rules/#lib-message-rules","page":"Message update rules","title":"Message update rules","text":"","category":"section"},{"location":"lib/rules/rules/","page":"Message update rules","title":"Message update rules","text":"rule\n@rule\n@call_rule\nReactiveMP.print_rules_table","category":"page"},{"location":"lib/rules/rules/#ReactiveMP.rule","page":"Message update rules","title":"ReactiveMP.rule","text":"rule(fform, on, vconstraint, mnames, messages, qnames, marginals, meta, __node)\n\nThis function is used to compute an outbound message for a given node\n\nArguments\n\nfform: Functional form of the node in form of a type of the node, e.g. ::Type{ <: NormalMeanVariance } or ::typeof(+)\non: Outbound interface's tag for which a message has to be computed, e.g. ::Val{:out} or ::Val{:μ}\nvconstraint: Variable constraints for an outbound interface, e.g. Marginalisation or MomentMatching\nmnames: Ordered messages names in form of the Val type, eg. ::Val{ (:mean, :precision) }\nmessages: Tuple of message of the same length as mnames used to compute an outbound message\nqnames: Ordered marginal names in form of the Val type, eg. ::Val{ (:mean, :precision) }\nmarginals: Tuple of marginals of the same length as qnames used to compute an outbound message\nmeta: Extra meta information\naddons: Extra addons information\n__node: Node reference\n\nFor all available rules, see ReactiveMP.print_rules_table().\n\nSee also: @rule, marginalrule, @marginalrule\n\n\n\n\n\n","category":"function"},{"location":"lib/rules/rules/#ReactiveMP.@rule","page":"Message update rules","title":"ReactiveMP.@rule","text":"@rule NodeType(:Edge, Constraint) (Arguments..., [ meta::MetaType ]) = begin\n    # rule body\n    return ...\nend\n\nThe @rule macro help to define new methods for the rule function. It works particularly well in combination with the @node macro. It has a specific structure, which must specify:\n\nNodeType: must be a valid Julia type. If some attempt to define a rule for a Julia function (for example +), use typeof(+)\nEdge: edge label, usually edge labels are defined with the @node macro\nConstrain: DEPRECATED, please just use the Marginalisation label\nArguments: defines a list of the input arguments for the rule\nm_* prefix indicates that the argument is of type Message from the edge *\nq_* prefix indicates that the argument is of type Marginal on the edge *\nMeta::MetaType - optionally, a user can specify a Meta object of type MetaType.  This can be useful is some attempts to try different rules with different approximation methods or if the rule itself requires some temporary storage or cache.  The default meta is nothing.\n\nHere are various examples of the @rule macro usage:\n\nBelief-Propagation (or Sum-Product) message update rule for the NormalMeanVariance node  toward the :μ edge with the Marginalisation constraint. Input arguments are m_out and m_v, which are the messages from the corresponding edges out and v and have the type PointMass.\n\n@rule NormalMeanVariance(:μ, Marginalisation) (m_out::PointMass, m_v::PointMass) = NormalMeanVariance(mean(m_out), mean(m_v))\n\nMean-field message update rule for the NormalMeanVariance node towards the :μ edge with the Marginalisation constraint. Input arguments are q_out and q_v, which are the marginals on the corresponding edges out and v of type Any.\n\n@rule NormalMeanVariance(:μ, Marginalisation) (q_out::Any, q_v::Any) = NormalMeanVariance(mean(q_out), mean(q_v))\n\nStructured Variational message update rule for the NormalMeanVariance node towards the :out edge with the Marginalisation constraint. Input arguments are m_μ, which is a message from the μ edge of type UnivariateNormalDistributionsFamily, and q_v, which is a marginal on the v edge of type Any.\n\n@rule NormalMeanVariance(:out, Marginalisation) (m_μ::UnivariateNormalDistributionsFamily, q_v::Any) = begin\n    m_μ_mean, m_μ_cov = mean_cov(m_μ)\n    return NormalMeanVariance(m_μ_mean, m_μ_cov + mean(q_v))\nend\n\nSee also: rule, marginalrule, [@marginalrule], @call_rule\n\n\n\n\n\n","category":"macro"},{"location":"lib/rules/rules/#ReactiveMP.@call_rule","page":"Message update rules","title":"ReactiveMP.@call_rule","text":"@call_rule NodeType(:edge, Constraint) (argument1 = value1, argument2 = value2, ..., [ meta = ..., addons = ... ])\n\nThe @call_rule macro helps to call the rule method with an easier syntax.  The structure of the macro is almost the same as in the @rule macro, but there is no begin ... end block, but instead each argument must have a specified value with the = operator.\n\nThe @call_rule accepts optional list of options before the functional form specification, for example:\n\n@call_rule [ return_addons = true ] NodeType(:edge, Constraint) (argument1 = value1, argument2 = value2, ..., [ meta = ..., addons = ... ])\n\nThe list of available options is:\n\nreturn_addons - forces the @call_rule to return the tuple of (result, addons)\n\nSee also: @rule, rule, @call_marginalrule\n\n\n\n\n\n","category":"macro"},{"location":"lib/rules/rules/#ReactiveMP.print_rules_table","page":"Message update rules","title":"ReactiveMP.print_rules_table","text":"Prints a table of all message passing update rules in ReactiveMP.\n\nUse `Markdown.parse` on the output of this function to get a prettified table.\n\n\n\n\n\n","category":"function"},{"location":"lib/rules/rules/#lib-marginal-rules","page":"Message update rules","title":"Marginal update rules","text":"","category":"section"},{"location":"lib/rules/rules/","page":"Message update rules","title":"Message update rules","text":"marginalrule\n@marginalrule\n@call_marginalrule","category":"page"},{"location":"lib/rules/rules/#ReactiveMP.marginalrule","page":"Message update rules","title":"ReactiveMP.marginalrule","text":"marginalrule(fform, on, mnames, messages, qnames, marginals, meta, __node)\n\nThis function is used to compute a local joint marginal for a given node\n\nArguments\n\nfform: Functional form of the node in form of a type of the node, e.g. ::Type{ <: NormalMeanVariance } or ::typeof(+)\non: Local joint marginal tag , e.g. ::Val{ :mean_precision } or ::Val{ :out_mean_precision }\nmnames: Ordered messages names in form of the Val type, eg. ::Val{ (:mean, :precision) }\nmessages: Tuple of message of the same length as mnames used to compute an outbound message\nqnames: Ordered marginal names in form of the Val type, eg. ::Val{ (:mean, :precision) }\nmarginals: Tuple of marginals of the same length as qnames used to compute an outbound message\nmeta: Extra meta information\n__node: Node reference\n\nSee also: rule, @rule @marginalrule\n\n\n\n\n\n","category":"function"},{"location":"lib/rules/rules/#ReactiveMP.@marginalrule","page":"Message update rules","title":"ReactiveMP.@marginalrule","text":"@marginalrule NodeType(:Cluster) (Arguments..., [ meta::MetaType ]) = begin\n    # rule body\n    return ...\nend\n\nThe @marginalrule macro help to define new methods for the marginalrule function. It works particularly well in combination with the @node macro. It has a specific structure, which must specify:\n\nNodeType: must be a valid Julia type. If some attempt to define a rule for a Julia function (for example +), use typeof(+)\nCluster: edge cluster that contains joined edge labels with the _ symbol. Usually edge labels are defined with the @node macro\nArguments: defines a list of the input arguments for the rule\nm_* prefix indicates that the argument is of type Message from the edge *\nq_* prefix indicates that the argument is of type Marginal on the edge *\nMeta::MetaType - optionally, a user can specify a Meta object of type MetaType.  This can be useful is some attempts to try different rules with different approximation methods or if the rule itself requires some temporary storage or cache.  The default meta is nothing.\n\nThe @marginalrule can return a NamedTuple in the return statement. This would indicate some variables in the joint marginal  for the Cluster are independent and the joint itself is factorised. For example if some attempts to compute a marginal for the q(x, y) it is possible to return (x = ..., y = ...) as the result of the computation to indicate that q(x, y) = q(x)q(y).\n\nHere are various examples of the @marginalrule macro usage:\n\nMarginal computation rule around the NormalMeanPrecision node for the q(out, μ). The rule accepts arguments m_out and m_μ, which are the messages \n\nfrom the out and μ edges respectively, and q_τ which is the marginal on the edge τ.\n\n@marginalrule NormalMeanPrecision(:out_μ) (m_out::UnivariateNormalDistributionsFamily, m_μ::UnivariateNormalDistributionsFamily, q_τ::Any) = begin\n    xi_out, W_out = weightedmean_precision(m_out)\n    xi_μ, W_μ     = weightedmean_precision(m_μ)\n\n    W_bar = mean(q_τ)\n\n    W  = [W_out+W_bar -W_bar; -W_bar W_μ+W_bar]\n    xi = [xi_out; xi_μ]\n\n    return MvNormalWeightedMeanPrecision(xi, W)\nend\n\nMarginal computation rule around the NormalMeanPrecision node for the q(out, μ). The rule accepts arguments m_out and m_μ, which are the messages from the \n\nout and μ edges respectively, and q_τ which is the marginal on the edge τ. In this example the result of the computation is a NamedTuple\n\n@marginalrule NormalMeanPrecision(:out_μ) (m_out::PointMass, m_μ::UnivariateNormalDistributionsFamily, q_τ::Any) = begin\n    return (out = m_out, μ = prod(ClosedProd(), NormalMeanPrecision(mean(m_out), mean(q_τ)), m_μ))\nend\n\n\n\n\n\n","category":"macro"},{"location":"lib/rules/rules/#ReactiveMP.@call_marginalrule","page":"Message update rules","title":"ReactiveMP.@call_marginalrule","text":"@call_marginalrule NodeType(:edge) (argument1 = value1, argument2 = value2, ..., [ meta = ... ])\n\nThe @call_marginalrule macro helps to call the marginalrule method with an easier syntax.  The structure of the macro is almost the same as in the @marginalrule macro, but there is no begin ... end block,  but instead each argument must have a specified value with the = operator.\n\nSee also: @marginalrule, marginalrule, @call_rule\n\n\n\n\n\n","category":"macro"},{"location":"lib/rules/rules/#lib-rules-tests","page":"Message update rules","title":"Testing utilities for the update rules","text":"","category":"section"},{"location":"lib/rules/rules/","page":"Message update rules","title":"Message update rules","text":"ReactiveMP.@test_rules\nReactiveMP.@test_marginalrules","category":"page"},{"location":"lib/rules/rules/#ReactiveMP.@test_rules","page":"Message update rules","title":"ReactiveMP.@test_rules","text":"@test_rules [options] rule [ test_entries... ]\n\nThe @test_rules macro generates test cases for message update rules for probabilistic programming models that follow the \"message passing\" paradigm. It takes a rule specification as input and generates a set of tests based on that specification. This macro is provided by ReactiveMP.\n\nNote: The Test module must be imported explicitly. The @test_rules macro tries to use the @test macro, which must be defined globally.\n\nArguments\n\nThe macro takes three arguments:\n\noptions: An optional argument that specifies the options for the test generation process. See below for details.\nrule: A rule specification in the same format as the @rule macro, e.g. Beta(:out, Marginalisation) or NormalMeanVariance(:μ, Marginalisation).\ntest_entries: An array of named tuples (input = ..., output = ...). The input entry has the same format as the input for the @rule macro. The output entry specifies the expected output.\n\nOptions\n\nThe following options are available:\n\ncheck_type_promotion: By default, this option is set to false. If set to true, the macro generates an extensive list of extra tests that aim to check the correct type promotion within the tests. For example, if all inputs are of type Float32, then the expected output should also be of type Float32. See the paramfloattype and convert_paramfloattype functions for details.\natol: Sets the desired accuracy for the tests. The tests use the custom_rule_isapprox function from ReactiveMP to check if outputs are approximately the same. This argument can be either a single number or an array of key => value pairs.\nextra_float_types: A set of extra float types to be used in the check_type_promotion tests. This argument has no effect if check_type_promotion is set to false.\n\nThe default values for the atol option are:\n\nFloat32: 1e-4\nFloat64: 1e-6\nBigFloat: 1e-8\n\nExamples\n\n\n@test_rules [check_type_promotion = true] Beta(:out, Marginalisation) [\n    (input = (m_a = PointMass(1.0), m_b = PointMass(2.0)), output = Beta(1.0, 2.0)),\n    (input = (m_a = PointMass(2.0), m_b = PointMass(2.0)), output = Beta(2.0, 2.0)),\n    (input = (m_a = PointMass(3.0), m_b = PointMass(3.0)), output = Beta(3.0, 3.0))\n]\n\n@test_rules [check_type_promotion = true] Beta(:out, Marginalisation) [\n    (input = (q_a = PointMass(1.0), q_b = PointMass(2.0)), output = Beta(1.0, 2.0)),\n    (input = (q_a = PointMass(2.0), q_b = PointMass(2.0)), output = Beta(2.0, 2.0)),\n    (input = (q_a = PointMass(3.0), q_b = PointMass(3.0)), output = Beta(3.0, 3.0))\n]\n\nSee also: ReactiveMP.@test_marginalrules\n\n\n\n\n\n","category":"macro"},{"location":"lib/rules/rules/#ReactiveMP.@test_marginalrules","page":"Message update rules","title":"ReactiveMP.@test_marginalrules","text":"@test_marginalrules [options] rule [ test_entries... ]\n\nEffectively the same as @test_rules, but for marginal computation rules. See the documentation for @test_rules for more info.\n\nSee also: ReactiveMP.@test_rules\n\n\n\n\n\n","category":"macro"},{"location":"lib/rules/rules/#lib-rules-table","page":"Message update rules","title":"Table of available update rules","text":"","category":"section"},{"location":"lib/rules/rules/","page":"Message update rules","title":"Message update rules","text":"using ReactiveMP, Markdown\nMarkdown.parse(ReactiveMP.print_rules_table())","category":"page"},{"location":"lib/message/#lib-message","page":"Messages","title":"Messages implementation","text":"","category":"section"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"In our message passing framework one of the most important concepts is the message (wow!). Messages flow along edges of a factor graph and hold information about the part of the graph that it originates from. Usually this information is in a form of a probability distribution. Two common messages are belief propagation messages and variational messages, with are computed differently as shown below.","category":"page"},{"location":"lib/message/#Abstract-message-type","page":"Messages","title":"Abstract message type","text":"","category":"section"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"Both belief propagation and variational messages are subtypes of a AbstractMessage supertype.","category":"page"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"AbstractMessage","category":"page"},{"location":"lib/message/#ReactiveMP.AbstractMessage","page":"Messages","title":"ReactiveMP.AbstractMessage","text":"AbstractMessage\n\nAn abstract supertype for all concrete message types.\n\nSee also: Message\n\n\n\n\n\n","category":"type"},{"location":"lib/message/#lib-belief-propagation-message","page":"Messages","title":"Belief-Propagation (or Sum-Product) message","text":"","category":"section"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"(Image: message) Belief propagation message","category":"page"},{"location":"lib/message/#lib-variational-message","page":"Messages","title":"Variational message","text":"","category":"section"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"(Image: message) Variational message with structured factorisation q(x, y)q(z) assumption","category":"page"},{"location":"lib/message/#Message-type","page":"Messages","title":"Message type","text":"","category":"section"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"All messages are encoded with the type Message. ","category":"page"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"Message\nReactiveMP.materialize!","category":"page"},{"location":"lib/message/#ReactiveMP.Message","page":"Messages","title":"ReactiveMP.Message","text":"Message{D, A} <: AbstractMessage\n\nMessage structure encodes a Belief Propagation message, which holds some data that usually a probability distribution, but can also be an arbitrary object. Message acts as a proxy structure to data object and proxies most of the statistical functions, e.g. mean, mode, cov etc.\n\nArguments\n\ndata::D: message always holds some data object associated with it\nis_clamped::Bool, specifies if this message is clamped\nis_initial::Bool, specifies if this message is initial\naddons::A, specifies the addons of the message\n\nExample\n\njulia> distribution = Gamma(10.0, 2.0)\nDistributions.Gamma{Float64}(α=10.0, θ=2.0)\n\njulia> message = Message(distribution, false, true, nothing)\nMessage(Distributions.Gamma{Float64}(α=10.0, θ=2.0))\n\njulia> mean(message) \n20.0\n\njulia> getdata(message)\nDistributions.Gamma{Float64}(α=10.0, θ=2.0)\n\njulia> is_clamped(message)\nfalse\n\njulia> is_initial(message)\ntrue\n\n\nSee also: AbstractMessage, ReactiveMP.materialize!\n\n\n\n\n\n","category":"type"},{"location":"lib/message/#ReactiveMP.materialize!","page":"Messages","title":"ReactiveMP.materialize!","text":"materialize!(message::AbstractMessage)\n\nMaterializes an abstract message and converts it to be of type Message.\n\nSee also: Message\n\n\n\n\n\n","category":"function"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"From an implementation point a view the Message structure does nothing but hold some data object and redirects most of the statistical related functions to that data object.  However, this object is used extensively in Julia's multiple dispatch.  Our implementation also uses extra is_initial and is_clamped fields to determine if product of two messages results in is_initial or is_clamped posterior marginal. The final field contains the addons. These contain additional information on top of the functional form of the distribution, such as its scaling or computation history.","category":"page"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"using ReactiveMP, BayesBase, Distributions, ExponentialFamily","category":"page"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"distribution = NormalMeanPrecision(0.0, 1.0)\nmessage      = Message(distribution, false, true, nothing)","category":"page"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"mean(message), precision(message)","category":"page"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"logpdf(message, 1.0)","category":"page"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"is_clamped(message), is_initial(message)","category":"page"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"The user should not really interact with Message structure while working with ReactiveMP unless doing some advanced inference procedures that involve prediction.","category":"page"},{"location":"lib/nodes/nodes/#lib-node","page":"Overview","title":"Nodes implementation","text":"","category":"section"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"In the message passing framework, one of the most important concepts is a factor node. A factor node represents a local function in a factorised representation of a generative model.","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"note: Note\nTo quickly check the list of all available factor nodes that can be used in the model specification language, call ?make_node or Base.doc(make_node).","category":"page"},{"location":"lib/nodes/nodes/#lib-custom-node","page":"Overview","title":"Adding a custom node","text":"","category":"section"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"ReactiveMP.jl exports the @node macro that allows for quick definition of a factor node with a fixed number of edges. The interface is the following:","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"struct MyNewCustomNode end\n\n@node MyNewCustomNode   Stochastic         [ x, y, z ]\n#     ^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^      ^^^^^^^^^^^\n#     Node's tag/name   Node's type        A fixed set of edges\n#                       Another possible   The very first edge (in this example `x`) is considered\n#                       value is           to be the output of the node\n#                       `Deterministic`","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"This expression registers a new node that can be used with the inference engine. Note howeve, that the @node macro does not generate any message passing update rules. These must be defined using the @rule macro.","category":"page"},{"location":"lib/nodes/nodes/#lib-node-types","page":"Overview","title":"Node types","text":"","category":"section"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"We distinguish different types of factor nodes in order to have better control over Bethe Free Energy computation. Each factor node has either the Deterministic or Stochastic functional form type.","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"Deterministic\nStochastic\nisdeterministic\nisstochastic\nsdtype","category":"page"},{"location":"lib/nodes/nodes/#ReactiveMP.Deterministic","page":"Overview","title":"ReactiveMP.Deterministic","text":"Deterministic\n\nDeterministic object used to parametrize factor node object with determinstic type of relationship between variables.\n\nSee also: Stochastic, isdeterministic, isstochastic, sdtype\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/nodes/#ReactiveMP.Stochastic","page":"Overview","title":"ReactiveMP.Stochastic","text":"Stochastic\n\nStochastic object used to parametrize factor node object with stochastic type of relationship between variables.\n\nSee also: Deterministic, isdeterministic, isstochastic, sdtype\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/nodes/#ReactiveMP.isdeterministic","page":"Overview","title":"ReactiveMP.isdeterministic","text":"isdeterministic(node)\n\nFunction used to check if factor node object is deterministic or not. Returns true or false.\n\nSee also: Deterministic, Stochastic, isstochastic, sdtype\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/nodes/#ReactiveMP.isstochastic","page":"Overview","title":"ReactiveMP.isstochastic","text":"isstochastic(node)\n\nFunction used to check if factor node object is stochastic or not. Returns true or false.\n\nSee also: Deterministic, Stochastic, isdeterministic, sdtype\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/nodes/#ReactiveMP.sdtype","page":"Overview","title":"ReactiveMP.sdtype","text":"sdtype(object)\n\nReturns either Deterministic or Stochastic for a given object (if defined).\n\nSee also: Deterministic, Stochastic, isdeterministic, isstochastic\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"using ReactiveMP, BayesBase, Distributions, ExponentialFamily","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"For example the + node has the Deterministic type:","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"plus_node = make_node(+)\n\nprintln(\"Is `+` node deterministic: \", isdeterministic(plus_node))\nprintln(\"Is `+` node stochastic: \", isstochastic(plus_node))\nnothing #hide","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"On the other hand, the Bernoulli node has the Stochastic type:","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"bernoulli_node = make_node(Bernoulli)\n\nprintln(\"Is `Bernoulli` node deterministic: \", isdeterministic(bernoulli_node))\nprintln(\"Is `Bernoulli` node stochastic: \", isstochastic(bernoulli_node))","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"To get an actual instance of the type object we use sdtype function:","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"println(\"sdtype() of `+` node is \", sdtype(plus_node))\nprintln(\"sdtype() of `Bernoulli` node is \", sdtype(bernoulli_node))\nnothing #hide","category":"page"},{"location":"lib/nodes/nodes/#lib-node-functional-dependencies-pipeline","page":"Overview","title":"Node functional dependencies pipeline","text":"","category":"section"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"The generic implementation of factor nodes in ReactiveMP supports custom functional dependency pipelines. Briefly, the functional dependencies pipeline defines what dependencies are need to compute a single message. As an example, consider the belief-propagation message update equation for a factor node f with three edges: x, y and z:","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"mu(x) = int mu(y) mu(z) f(x y z) mathrmdy mathrmdz","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"Here we see that in the standard setting for the belief-propagation message out of edge x, we need only messages from the edges y and z. In contrast, consider the variational message update rule equation with mean-field assumption:","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"mu(x) = exp int q(y) q(z) log f(x y z) mathrmdy mathrmdz","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"We see that in this setting, we do not need messages mu(y) and mu(z), but only the marginals q(y) and q(z). The purpose of a functional dependencies pipeline is to determine functional dependencies (a set of messages or marginals) that are needed to compute a single message. By default, ReactiveMP.jl uses so-called DefaultFunctionalDependencies that correctly implements belief-propagation and variational message passing schemes (including both mean-field and structured factorisations). The full list of built-in pipelines is presented below:","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"ReactiveMP.DefaultFunctionalDependencies\nReactiveMP.RequireMessageFunctionalDependencies\nReactiveMP.RequireMarginalFunctionalDependencies\nReactiveMP.RequireEverythingFunctionalDependencies","category":"page"},{"location":"lib/nodes/nodes/#ReactiveMP.DefaultFunctionalDependencies","page":"Overview","title":"ReactiveMP.DefaultFunctionalDependencies","text":"DefaultFunctionalDependencies\n\nThis pipeline translates directly to enforcing a variational message passing scheme. In order to compute a message out of some edge, this pipeline requires messages from edges within the same edge-cluster and marginals over other edge-clusters.\n\nSee also: ReactiveMP.RequireMessageFunctionalDependencies, ReactiveMP.RequireMarginalFunctionalDependencies, ReactiveMP.RequireEverythingFunctionalDependencies\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/nodes/#ReactiveMP.RequireMessageFunctionalDependencies","page":"Overview","title":"ReactiveMP.RequireMessageFunctionalDependencies","text":"RequireMessageFunctionalDependencies(indices::Tuple, start_with::Tuple)\n\nThe same as DefaultFunctionalDependencies, but in order to compute a message out of some edge also requires the inbound message on the this edge.\n\nArguments\n\nindices::Tuple, tuple of integers, which indicates what edges should require inbound messages\nstart_with::Tuple, tuple of nothing or <:Distribution, which specifies the initial inbound messages for edges in indices\n\nNote: start_with uses setmessage! mechanism, hence, it can be visible by other listeners on the same edge. Explicit call to setmessage! overwrites whatever has been passed in start_with.\n\n@model macro accepts a simplified construction of this pipeline:\n\n@model function some_model()\n    # ...\n    y ~ NormalMeanVariance(x, τ) where {\n        pipeline = RequireMessage(x = vague(NormalMeanPrecision),     τ)\n                                  # ^^^                               ^^^\n                                  # request 'inbound' for 'x'         we may do the same for 'τ',\n                                  # and initialise with `vague(...)`  but here we skip initialisation\n    }\n    # ...\nend\n\nDeprecation warning: RequireInboundFunctionalDependencies has been deprecated in favor of RequireMessageFunctionalDependencies.\n\nSee also: ReactiveMP.DefaultFunctionalDependencies, ReactiveMP.RequireMarginalFunctionalDependencies, ReactiveMP.RequireEverythingFunctionalDependencies\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/nodes/#ReactiveMP.RequireMarginalFunctionalDependencies","page":"Overview","title":"ReactiveMP.RequireMarginalFunctionalDependencies","text":"RequireMarginalFunctionalDependencies(indices::Tuple, start_with::Tuple)\n\nSimilar to DefaultFunctionalDependencies, but in order to compute a message out of some edge also requires the posterior marginal on that edge.\n\nArguments\n\nindices::Tuple, tuple of integers, which indicates what edges should require their own marginals\nstart_with::Tuple, tuple of nothing or <:Distribution, which specifies the initial marginal for edges in indices\n\nNote: start_with uses the setmarginal! mechanism, hence it can be visible to other listeners on the same edge. Explicit calls to setmarginal! overwrites whatever has been passed in start_with.\n\n@model macro accepts a simplified construction of this pipeline:\n\n@model function some_model()\n    # ...\n    y ~ NormalMeanVariance(x, τ) where {\n        pipeline = RequireMarginal(x = vague(NormalMeanPrecision),     τ)\n                                   # ^^^                               ^^^\n                                   # request 'marginal' for 'x'        we may do the same for 'τ',\n                                   # and initialise with `vague(...)`  but here we skip initialisation\n    }\n    # ...\nend\n\nNote: The simplified construction in @model macro syntax is only available in GraphPPL.jl of version >2.2.0.\n\nSee also: ReactiveMP.DefaultFunctionalDependencies, ReactiveMP.RequireMessageFunctionalDependencies, ReactiveMP.RequireEverythingFunctionalDependencies\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/nodes/#ReactiveMP.RequireEverythingFunctionalDependencies","page":"Overview","title":"ReactiveMP.RequireEverythingFunctionalDependencies","text":"RequireEverythingFunctionalDependencies\n\nThis pipeline specifies that in order to compute a message of some edge update rules request everything that is available locally. This includes all inbound messages (including on the same edge) and marginals over all local edge-clusters (this may or may not include marginals on single edges, depends on the local factorisation constraint).\n\nSee also: DefaultFunctionalDependencies, RequireMessageFunctionalDependencies, RequireMarginalFunctionalDependencies\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/nodes/#lib-node-traits","page":"Overview","title":"Node traits","text":"","category":"section"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"Each factor node has to define the ReactiveMP.as_node_functional_form trait function and to specify a ReactiveMP.ValidNodeFunctionalForm  singleton as a return object. By default ReactiveMP.as_node_functional_form returns ReactiveMP.UndefinedNodeFunctionalForm.  Objects that do not specify this property correctly cannot be used in model specification.","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"note: Note\n@node macro does that automatically","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"ReactiveMP.ValidNodeFunctionalForm\nReactiveMP.UndefinedNodeFunctionalForm\nReactiveMP.as_node_functional_form","category":"page"},{"location":"lib/nodes/nodes/#ReactiveMP.ValidNodeFunctionalForm","page":"Overview","title":"ReactiveMP.ValidNodeFunctionalForm","text":"ValidNodeFunctionalForm\n\nTrait specification for an object that can be used in model specification as a factor node.\n\nSee also: ReactiveMP.as_node_functional_form, ReactiveMP.UndefinedNodeFunctionalForm\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/nodes/#ReactiveMP.UndefinedNodeFunctionalForm","page":"Overview","title":"ReactiveMP.UndefinedNodeFunctionalForm","text":"UndefinedNodeFunctionalForm\n\nTrait specification for an object that can not be used in model specification as a factor node.\n\nSee also: ReactiveMP.as_node_functional_form, ReactiveMP.ValidNodeFunctionalForm\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/nodes/#ReactiveMP.as_node_functional_form","page":"Overview","title":"ReactiveMP.as_node_functional_form","text":"as_node_functional_form(object)\n\nDetermines object node functional form trait specification. Returns either ValidNodeFunctionalForm() or UndefinedNodeFunctionalForm().\n\nSee also: ReactiveMP.ValidNodeFunctionalForm, ReactiveMP.UndefinedNodeFunctionalForm\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/flow/#lib-nodes-flow","page":"Flow","title":"Flow node","text":"","category":"section"},{"location":"lib/nodes/flow/","page":"Flow","title":"Flow","text":"See also Flow tutorial for a comprehensive guide on using flows in ReactiveMP.","category":"page"},{"location":"lib/nodes/flow/","page":"Flow","title":"Flow","text":"PlanarFlow\nRadialFlow\nFlowModel\nCompiledFlowModel\ncompile\nAdditiveCouplingLayer\nInputLayer\nPermutationLayer\nFlowMeta","category":"page"},{"location":"lib/nodes/flow/#ReactiveMP.PlanarFlow","page":"Flow","title":"ReactiveMP.PlanarFlow","text":"The PlanarFlow function is defined as\n\nf(bfx) = bfx + bfu tanh(bfw^top bfx + b)\n\nwith input and output dimension D. Here bfxin mathbbR^D represents the input of the function. Furthermore bfuin mathbbR^D, bfwin mathbbR^D and binmathbbR represent the parameters of the function. The function contracts and expands the input space. \n\nThis function has been introduced in:\n\nRezende, Danilo, and Shakir Mohamed. \"Variational inference with normalizing flows.\" International conference on machine learning. PMLR, 2015.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/flow/#ReactiveMP.RadialFlow","page":"Flow","title":"ReactiveMP.RadialFlow","text":"The RadialFlow function is defined as\n\nf(bfx) = bfx + fracbeta(bfz - bfz_0)alpha + bfz - bfz_0\n\nwith input and output dimension D. Here bfxin mathbbR^D represents the input of the function. Furthermore bfz_0in mathbbR^D, alphain mathbbR and betainmathbbR represent the parameters of the function. The function contracts and expands the input space. \n\nThis function has been introduced in:\n\nRezende, Danilo, and Shakir Mohamed. \"Variational inference with normalizing flows.\" International conference on machine learning. PMLR, 2015.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/flow/#ReactiveMP.FlowModel","page":"Flow","title":"ReactiveMP.FlowModel","text":"The FlowModel structure is the most generic type of Flow model, in which the layers are not constrained to be of a specific type. The FlowModel structure contains the input dimensionality and a tuple of layers and can be constructed as FlowModel( dim, (layer1, layer2, ...) ).\n\nNote: this model can be specialized by constraining the types of layers. This potentially allows for more efficient specialized methods that can deal with specifics of these layers, such as triangular jacobian matrices.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/flow/#ReactiveMP.CompiledFlowModel","page":"Flow","title":"ReactiveMP.CompiledFlowModel","text":"The CompiledFlowModel structure is the most generic type of compiled Flow model, in which the layers are not constrained to be of a specific type. The FlowModel structure contains the input dimension and a tuple of compiled layers. Do not manually create a CompiledFlowModel! Instead create a FlowModel first and compile it with compile(model::FlowModel). This will make sure that all layers/mappings are configured with the proper dimensionality and with randomly sampled parameters. Alternatively, if you would like to pass your own parameters, call compile(model::FlowModel, params::Vector).\n\nNote: this model can be specialized by constraining the types of layers. This potentially allows for more efficient specialized methods that can deal with specifics of these layers, such as triangular jacobian matrices.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/flow/#ReactiveMP.compile","page":"Flow","title":"ReactiveMP.compile","text":"compile() compiles a model by setting its parameters. It randomly sets parameter values in the layers and flows such that inference in the model can be obtained.\n\nInput arguments\n\nmodel::FlowModel - a model of which the dimensionality of its layers/flows has been initialized, but its parameters have not been set.\n\nReturn arguments\n\n::CompiledFlowModel - a compiled model with set parameters, such that it can be used for processing data.\n\n\n\n\n\ncompile(model::FlowModel, params::Vector) lets you initialize a model model with a vector of parameters params.\n\nInput arguments\n\nmodel::FlowModel - a model of which the dimensionality of its layers/flows has been initialized, but its parameters have not been set.\nparams::Vector   - a vector of parameters with which the model should be compiled.\n\nReturn arguments\n\n::CompiledFlowModel - a compiled model with set parameters, such that it can be used for processing data.\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/flow/#ReactiveMP.AdditiveCouplingLayer","page":"Flow","title":"ReactiveMP.AdditiveCouplingLayer","text":"The additive coupling layer specifies an invertible function bfy = g(bfx) following the specific structure (for the mapping g mathbbR^2 rightarrow mathbbR^2):\n\n    beginalign\n        y_1 = x_1 \n        y_2 = x_2 + f(x_1)\n    endalign\n\nwhere f(cdot) denotes an arbitrary function with mapping f mathbbR rightarrow mathbbR. This function can be chosen arbitrarily complex. Non-linear functions (neural networks) are often chosen to model complex relationships. From the definition of the model, invertibility can be easily achieved as\n\n    beginalign\n        x_1 = y_1 \n        x_2 = y_2 - f(y_1)\n    endalign\n\nThe current implementation only allows for the mapping g mathbbR^2 rightarrow mathbbR^2, although this layer can be generalized for arbitrary input dimensions.\n\nAdditiveCouplingLayer(f <: AbstractCouplingFlow) creates the layer structure with function f.\n\nExample\n\nf = PlanarFlow()\nlayer = AdditiveCouplingLayer(f)\n\nThis layer structure has been introduced in:\n\nDinh, Laurent, David Krueger, and Yoshua Bengio. \"Nice: Non-linear independent components estimation.\" arXiv preprint arXiv:1410.8516 (2014).\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/flow/#ReactiveMP.InputLayer","page":"Flow","title":"ReactiveMP.InputLayer","text":"The input layer specifies the input dimension to a flow model.\n\nlayer = InputLayer(3)\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/flow/#ReactiveMP.PermutationLayer","page":"Flow","title":"ReactiveMP.PermutationLayer","text":"The permutation layer specifies an invertible mapping bfy = g(bfx) = Pbfx where P is a permutation matrix.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/flow/#ReactiveMP.FlowMeta","page":"Flow","title":"ReactiveMP.FlowMeta","text":"The FlowMeta structure contains the meta data of the Flow factor node. More specifically, it contains the model of the Flow factor node. The FlowMeta structure can be constructed as FlowMeta(model). Make sure that the flow model has been compiled.\n\nThe FlowMeta structure is required for the Flow factor node and can be included with the Flow node as: y ~ Flow(x) where { meta = FlowMeta(...) }\n\n\n\n\n\n","category":"type"},{"location":"extra/contributing/#Contribution-guidelines","page":"Contributing","title":"Contribution guidelines","text":"","category":"section"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"We welcome all possible contributors. This page details the some of the guidelines that should be followed when contributing to this package.","category":"page"},{"location":"extra/contributing/#Reporting-bugs","page":"Contributing","title":"Reporting bugs","text":"","category":"section"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"We track bugs using GitHub issues. We encourage you to write complete, specific, reproducible bug reports. Mention the versions of Julia and ReactiveMP for which you observe unexpected behavior. Please provide a concise description of the problem and complement it with code snippets, test cases, screenshots, tracebacks or any other information that you consider relevant. This will help us to replicate the problem and narrow the search space for solutions.","category":"page"},{"location":"extra/contributing/#Suggesting-features","page":"Contributing","title":"Suggesting features","text":"","category":"section"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"We welcome new feature proposals. However, before submitting a feature request, consider a few things:","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"Does the feature require changes in the core ReactiveMP.jl code? If it doesn't (for example, you would like to add a factor node for a particular application), you can add local extensions in your script/notebook or consider making a separate repository for your extensions.\nIf you would like to add an implementation of a feature that changes a lot in the core ReactiveMP.jl code, please open an issue on GitHub and describe your proposal first. This will allow us to discuss your proposal with you before you invest your time in implementing something that may be difficult to merge later on.","category":"page"},{"location":"extra/contributing/#Contributing-code","page":"Contributing","title":"Contributing code","text":"","category":"section"},{"location":"extra/contributing/#Installing-ReactiveMP","page":"Contributing","title":"Installing ReactiveMP","text":"","category":"section"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"We suggest that you use the dev command from the new Julia package manager to install ReactiveMP.jl for development purposes. To work on your fork of ReactiveMP.jl, use your fork's URL address in the dev command, for example:","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"] dev git@github.com:your_username/ReactiveMP.jl.git","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"The dev command clones ReactiveMP.jl to ~/.julia/dev/ReactiveMP. All local changes to ReactiveMP code will be reflected in imported code.","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"note: Note\nIt is also might be useful to install Revise.jl package as it allows you to modify code and use the changes without restarting Julia.","category":"page"},{"location":"extra/contributing/#Committing-code","page":"Contributing","title":"Committing code","text":"","category":"section"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"We use the standard GitHub Flow workflow where all contributions are added through pull requests. In order to contribute, first fork the repository, then commit your contributions to your fork, and then create a pull request on the master branch of the ReactiveMP.jl repository.","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"Before opening a pull request, please make sure that all tests pass without failing! All demos (can be found in /demo/ directory) and benchmarks (can be found in /benchmark/ directory) have to run without errors as well.","category":"page"},{"location":"extra/contributing/#Style-conventions","page":"Contributing","title":"Style conventions","text":"","category":"section"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"note: Note\nReactiveMP.jl repository contains scripts to automatically format code according to our guidelines. Use make format command to fix code style. This command overwrites files.","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"We use default Julia style guide. We list here a few important points and our modifications to the Julia style guide:","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"Use 4 spaces for indentation\nType names use UpperCamelCase. For example: AbstractFactorNode, RandomVariable, etc..\nFunction names are lowercase with underscores, when necessary. For example: activate!, randomvar, as_variable, etc..\nVariable names and function arguments use snake_case\nThe name of a method that modifies its argument(s) must end in !","category":"page"},{"location":"extra/contributing/#Unit-tests","page":"Contributing","title":"Unit tests","text":"","category":"section"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"We use the test-driven development (TDD) methodology for ReactiveMP.jl development. The test coverage should be as complete as possible. Please make sure that you write tests for each piece of code that you want to add.","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"All unit tests are located in the /test/ directory. The /test/ directory follows the structure of the /src/ directory. Each test file should have following filename format: test_*.jl. Some tests are also present in jldoctest docs annotations directly in the source code. See Julia's documentation about doctests.","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"The tests can be evaluated by running following command in the Julia REPL:","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"] test ReactiveMP","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"In addition tests can be evaluated by running following command in the ReactiveMP root directory:","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"make test","category":"page"},{"location":"extra/contributing/#Fixes-to-external-libraries","page":"Contributing","title":"Fixes to external libraries","text":"","category":"section"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"If a bug has been discovered in an external dependencies of the ReactiveMP.jl it is the best to open an issue  directly in the dependency's github repository. You use can use the fixes.jl file for hot-fixes before  a new release of the broken dependecy is available.","category":"page"},{"location":"extra/contributing/#Makefile","page":"Contributing","title":"Makefile","text":"","category":"section"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"ReactiveMP.jl uses Makefile for most common operations:","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"make help: Shows help snippet\nmake test: Run tests, supports extra arguments\nmake test test_args=\"distributions:normal_mean_variance\" would run tests only from distributions/test_normal_mean_variance.jl\nmake test test_args=\"distributions:normal_mean_variance models:lgssm\" would run tests both from distributions/test_normal_mean_variance.jl and models/test_lgssm.jl\nmake docs: Compile documentation\nmake benchmark: Run simple benchmark\nmake lint: Check codestyle\nmake format: Check and fix codestyle ","category":"page"},{"location":"extra/extensions/#Extensions-and-interaction-with-the-Julia-ecosystem","page":"Extensions and interaction with the Julia ecosystem","title":"Extensions and interaction with the Julia ecosystem","text":"","category":"section"},{"location":"extra/extensions/","page":"Extensions and interaction with the Julia ecosystem","title":"Extensions and interaction with the Julia ecosystem","text":"ReactiveMP.jl exports extra functionality if other Julia packages are loaded in the same environment.","category":"page"},{"location":"extra/extensions/#Optimisers.jl","page":"Extensions and interaction with the Julia ecosystem","title":"Optimisers.jl","text":"","category":"section"},{"location":"extra/extensions/","page":"Extensions and interaction with the Julia ecosystem","title":"Extensions and interaction with the Julia ecosystem","text":"The Optimizers.jl package defines many standard gradient-based optimisation rules, and tools for applying them to deeply nested models. The optimizers defined in the Optimziers.jl are compatible with the CVI approximation method.","category":"page"},{"location":"extra/extensions/#DiffResults.jl-(loaded-automatically-with-the-ForwardDiff.jl)","page":"Extensions and interaction with the Julia ecosystem","title":"DiffResults.jl (loaded automatically with the ForwardDiff.jl)","text":"","category":"section"},{"location":"extra/extensions/","page":"Extensions and interaction with the Julia ecosystem","title":"Extensions and interaction with the Julia ecosystem","text":"The DiffResults.jl provides the DiffResult type, which can be passed to in-place differentiation methods instead of an output buffer. If loaded in the current Julia session enables faster derivatives with the ForwardDiffGrad option in the CVI approximation method (in the Gaussian case).","category":"page"},{"location":"custom/custom-functional-form/#custom-functional-form","page":"Custom functional form","title":"Custom Functional Form Specification","text":"","category":"section"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"In a nutshell, functional form constraints defines a function that approximates the product of colliding messages and computes posterior marginal that can be used later on during the inference procedure. An important part of the functional forms constraint implementation is the prod function in the BayesBase package. For example, if we refer to our CustomFunctionalForm as to f we can see the whole functional form constraints pipeline as:","category":"page"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"q(x) = fleft(fracoverrightarrowmu(x)overleftarrowmu(x)int overrightarrowmu(x)overleftarrowmu(x) mathrmdxright)","category":"page"},{"location":"custom/custom-functional-form/#Interface","page":"Custom functional form","title":"Interface","text":"","category":"section"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"ReactiveMP.jl, however, uses some extra utility functions to define functional form constraint behaviour. Here we briefly describe all utility function. If you are only interested in the concrete example, you may directly head to the Custom Functional Form example at the end of this section.","category":"page"},{"location":"custom/custom-functional-form/#Abstract-super-type","page":"Custom functional form","title":"Abstract super type","text":"","category":"section"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"AbstractFormConstraint\nCompositeFormConstraint","category":"page"},{"location":"custom/custom-functional-form/#ReactiveMP.AbstractFormConstraint","page":"Custom functional form","title":"ReactiveMP.AbstractFormConstraint","text":"AbstractFormConstraint\n\nEvery functional form constraint is a subtype of AbstractFormConstraint abstract type.\n\nNote: this is not strictly necessary, but it makes automatic dispatch easier and compatible with the CompositeFormConstraint.\n\nSee also: CompositeFormConstraint\n\n\n\n\n\n","category":"type"},{"location":"custom/custom-functional-form/#ReactiveMP.CompositeFormConstraint","page":"Custom functional form","title":"ReactiveMP.CompositeFormConstraint","text":"CompositeFormConstraint\n\nCreates a composite form constraint that applies form constraints in order. The composed form constraints must be compatible and have the exact same form_check_strategy.  Any functional form constraint that defines is_point_mass_form_constraint() = true may be used only as the last element of the composition.\n\n\n\n\n\n","category":"type"},{"location":"custom/custom-functional-form/#Form-check-strategy","page":"Custom functional form","title":"Form check strategy","text":"","category":"section"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"Every custom functional form must implement a new method for the default_form_check_strategy function that returns either FormConstraintCheckEach or FormConstraintCheckLast.","category":"page"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"FormConstraintCheckLast: q(x) = f(μ1(x) * μ2(x) * μ3(x))\nFormConstraintCheckEach: q(x) = f(f(μ1(x) * μ2(x)) * μ3(x))","category":"page"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"default_form_check_strategy\nFormConstraintCheckEach\nFormConstraintCheckLast","category":"page"},{"location":"custom/custom-functional-form/#ReactiveMP.default_form_check_strategy","page":"Custom functional form","title":"ReactiveMP.default_form_check_strategy","text":"default_form_check_strategy(form_constraint)\n\nReturns a default check strategy (e.g. FormConstraintCheckEach or FormConstraintCheckEach) for a given form constraint object.\n\nSee also: FormConstraintCheckEach, FormConstraintCheckLast, constrain_form\n\n\n\n\n\n","category":"function"},{"location":"custom/custom-functional-form/#ReactiveMP.FormConstraintCheckEach","page":"Custom functional form","title":"ReactiveMP.FormConstraintCheckEach","text":"FormConstraintCheckEach\n\nThis form constraint check strategy checks functional form of the messages product after each product in an equality chain.  Usually if a variable has been connected to multiple nodes we want to perform multiple prod to obtain a posterior marginal. With this form check strategy constrain_form function will be executed after each subsequent prod function.\n\nSee also: FormConstraintCheckLast, default_form_check_strategy, constrain_form\n\n\n\n\n\n","category":"type"},{"location":"custom/custom-functional-form/#ReactiveMP.FormConstraintCheckLast","page":"Custom functional form","title":"ReactiveMP.FormConstraintCheckLast","text":"FormConstraintCheckEach\n\nThis form constraint check strategy checks functional form of the last messages product in the equality chain.  Usually if a variable has been connected to multiple nodes we want to perform multiple prod to obtain a posterior marginal. With this form check strategy constrain_form function will be executed only once after all subsequenct prod functions have been executed.\n\nSee also: FormConstraintCheckLast, default_form_check_strategy, constrain_form\n\n\n\n\n\n","category":"type"},{"location":"custom/custom-functional-form/#Prod-constraint","page":"Custom functional form","title":"Prod constraint","text":"","category":"section"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"Every custom functional form must implement a new method for the default_prod_constraint function that returns a proper prod_constraint object.","category":"page"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"default_prod_constraint","category":"page"},{"location":"custom/custom-functional-form/#ReactiveMP.default_prod_constraint","page":"Custom functional form","title":"ReactiveMP.default_prod_constraint","text":"default_prod_constraint(form_constraint)\n\nReturns a default prod constraint needed to apply a given form_constraint. For most form constraints this function returns ProdGeneric.\n\n\n\n\n\n","category":"function"},{"location":"custom/custom-functional-form/#Constrain-form,-a.k.a-f","page":"Custom functional form","title":"Constrain form, a.k.a f","text":"","category":"section"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"The main function that a custom functional form must implement, which we referred to as f in the beginning of this section, is the constrain_form function.","category":"page"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"constrain_form","category":"page"},{"location":"custom/custom-functional-form/#ReactiveMP.constrain_form","page":"Custom functional form","title":"ReactiveMP.constrain_form","text":"constrain_form(form_constraint, distribution)\n\nThis function must approximate distribution object in a form that satisfies form_constraint.\n\nSee also: FormConstraintCheckEach, FormConstraintCheckLast, default_form_check_strategy, is_point_mass_form_constraint\n\n\n\n\n\n","category":"function"},{"location":"custom/custom-functional-form/#Is-point-mass-form-constraint-(optional)","page":"Custom functional form","title":"Is point mass form constraint (optional)","text":"","category":"section"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"Every custom functional form may implement a new method for the is_point_mass_form_constraint function that returns either true or false. This is an utility function that simplifes computation of the Bethe Free Energy and is not strictly necessary.","category":"page"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"is_point_mass_form_constraint","category":"page"},{"location":"custom/custom-functional-form/#ReactiveMP.is_point_mass_form_constraint","page":"Custom functional form","title":"ReactiveMP.is_point_mass_form_constraint","text":"is_point_mass_form_constraint(form_constraint)\n\nSpecifies whether form constraint always returns PointMass estimates or not. For a given form_constraint returns either true or false.\n\nSee also: FormConstraintCheckEach, FormConstraintCheckLast, constrain_form\n\n\n\n\n\n","category":"function"},{"location":"custom/custom-functional-form/#Compatibility-with-@constraints-macro-(optional)","page":"Custom functional form","title":"Compatibility with @constraints macro (optional)","text":"","category":"section"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"To make custom functional form constraint compatible with the @constraints macro, it must implement a new method for the make_form_constraint function.","category":"page"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"make_form_constraint","category":"page"},{"location":"custom/custom-functional-form/#ReactiveMP.make_form_constraint","page":"Custom functional form","title":"ReactiveMP.make_form_constraint","text":"make_form_constraint(::Type, args...; kwargs...)\n\nCreates form constraint object based on passed type with given args and kwargs. Used to simplify form constraint specification.\n\nAs an example:\n\nmake_form_constraint(PointMass)\n\ncreates an instance of PointMassFormConstraint and \n\nmake_form_constraint(SampleList, 5000, LeftProposal())\n\nshould create an instance of SampleListFormConstraint.\n\nSee also: AbstractFormConstraint\n\n\n\n\n\n","category":"function"},{"location":"custom/custom-functional-form/#custom-functional-form-example","page":"Custom functional form","title":"Custom Functional Form Example","text":"","category":"section"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"In this demo we show how to build a custom functional form constraint that is compatible with the ReactiveMP.jl inference backend. An important part of the functional forms constraint implementation is the prod function in the BayesBase package. We show a relatively simple use-case, which might not be very useful in practice, but serves as a simple step-by-step guide. Assume that we want a specific posterior marginal of some random variable in our model to have a specific Gaussian parametrisation, for example mean-precision. We can use built-in NormalMeanPrecision distribution, but we still need to define our custom functional form constraint:","category":"page"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"using ReactiveMP, BayesBase\n\n# First we define our functional form structure with no fields\nstruct MeanPrecisionFormConstraint <: AbstractFormConstraint end","category":"page"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"Next we define the behaviour of our functional form constraint:","category":"page"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"ReactiveMP.is_point_mass_form_constraint(::MeanPrecisionFormConstraint) = false\nReactiveMP.default_form_check_strategy(::MeanPrecisionFormConstraint)   = FormConstraintCheckLast()\nReactiveMP.default_prod_constraint(::MeanPrecisionFormConstraint)       = GenericProd()\n\nfunction ReactiveMP.constrain_form(::MeanPrecisionFormConstraint, distribution) \n    # This is quite a naive assumption, that a given `dsitribution` object has `mean` and `precision` defined\n    # However this quantities might be approximated with some other external method, e.g. Laplace approximation\n    m = mean(distribution)      # or approximate with some other method\n    p = precision(distribution) # or approximate with some other method\n    return NormalMeanPrecision(m, p)\nend\n\nfunction ReactiveMP.constrain_form(::MeanPrecisionFormConstraint, distribution::BayesBase.ProductOf)\n    # ProductOf is the special case, read about this type more in the corresponding documentation section\n    # of the `BayesBase` package\n    # ... \nend","category":"page"},{"location":"custom/custom-addons/#custom-addons","page":"Custom addons","title":"Custom Addons","text":"","category":"section"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"Standard message passing schemes only pass along distributions to other nodes. However, for more advanced usage, there might be a need for passing along additional information in messages and/or marginals. One can for example think of passing along the scaling of the distribution or some information that specifies how the message or marginal was computed, i.e. which messages were used for its computation and which node was preceding it. Another use cases is saving extra debugging information inside messages themselves, e.g. what arguments have been used to compute a message.","category":"page"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"Addons provide a solution here. Basically, addons are structures that contain extra information that are passed along the graph with messages and marginals in a tuple. These addons can be extracted using the getaddons(message/marginal) function. Its usage and operations can differ significantly for each application, yet below gives a concise overview on how to implement them on your own.","category":"page"},{"location":"custom/custom-addons/#Example","page":"Custom addons","title":"Example","text":"","category":"section"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"Suppose that we wish to create an addon that counts the number of computations that preceded some message or marginal. This addon can be created by adding the file src/addons/count.jl and by including it in the ReactiveMP.jl file.","category":"page"},{"location":"custom/custom-addons/#Step-1:-Creating-the-addon-structure","page":"Custom addons","title":"Step 1: Creating the addon structure","text":"","category":"section"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"Let's start by defining our new addon structure. This might seem daunting, but basically only requires us to specify the information that we would like to collect. Just make sure that it is specified as a subtype of AbstractAddon. In our example this becomes:","category":"page"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"struct AddonCount{T} <: AbstractAddon\n    count :: T\nend","category":"page"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"You can add additional fields or functions for improved handling, such as get_count() or show() functions.","category":"page"},{"location":"custom/custom-addons/#Step-2:-Compute-addon-value-after-computing-a-message","page":"Custom addons","title":"Step 2: Compute addon value after computing a message","text":"","category":"section"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"As a second step we need to specify how the addon behaves when a new message is computed in a factor node.  For this purpose we need to implement a specialized version of the message_mapping_addon() function. This function accepts the mapping variables of the factor node and updates the addons by extending the tuple.","category":"page"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"In our example we could write","category":"page"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"# This specification assumes that the default value for addon is `AddonCount(nothing)`\nfunction message_mapping_addon(::AddonCount{Nothing}, mapping, messages, marginals, result, addons)\n\n    # get number of operations of messages\n    message_count = 0\n    for message in messages\n        message_count += getcount(message)\n    end\n\n    # get number of operations of marginals\n    marginal_count = 0\n    for marginal in marginals\n        marginal_count += getcount(marginal)\n    end\n\n    # extend addons with AddonCount() structure\n    return AddonCount(message_count + marginal_count + 1)\nend\n","category":"page"},{"location":"custom/custom-addons/#Step-3:-Computing-products","page":"Custom addons","title":"Step 3: Computing products","text":"","category":"section"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"The goal is to update the AddonCount structure when we multiply 2 messages. As a result, we need to write a function that allows us to define this behaviour. This function is called multiply_addons and accepts 5 arguments. In our example this becomes","category":"page"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"function multiply_addons(left_addon::AddonCount, right_addon::AddonCount, new_dist, left_dist, right_dist)\n    return AddonCount(left_addon.count + right_addon.count + 1)\nend","category":"page"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"here we add the number of operations from the addons that are being multiplied and we add one (for the current operation). we are aware that this is likely not valid for iterative message passing schemes, but it still serves as a nice example. the left_addon and right_addon argument specify the addoncount objects that are being multiplied. corresponding to these addons, there are the distributions left_dist and right_dist, which might contain information for computing the product. the new distribution new_dist ∝ left_dist * right_dist is also passed along for potentially reusing the result of earlier computations.","category":"page"},{"location":"custom/custom-addons/#More-information","page":"Custom addons","title":"More information","text":"","category":"section"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"For more advanced information check the implementation of the log-scale or memory addons.","category":"page"},{"location":"lib/methods/#lib-using-methods","page":"Exported methods","title":"Using methods from ReactiveMP","text":"","category":"section"},{"location":"lib/methods/","page":"Exported methods","title":"Exported methods","text":"In the Julia programming language (in contrast to Python for example) the most common way of loading a module is:","category":"page"},{"location":"lib/methods/","page":"Exported methods","title":"Exported methods","text":"using ReactiveMP","category":"page"},{"location":"lib/methods/","page":"Exported methods","title":"Exported methods","text":"A nice explanation about how modules/packages work in Julia can be found in the official documentation.","category":"page"},{"location":"lib/methods/","page":"Exported methods","title":"Exported methods","text":"In a nutshell, Julia automatically resolves all name collisions and there is no a lot of benefit of importing specific names, e.g.:","category":"page"},{"location":"lib/methods/","page":"Exported methods","title":"Exported methods","text":"import ReactiveMP: mean","category":"page"},{"location":"lib/methods/","page":"Exported methods","title":"Exported methods","text":"One of the reasons for that is that Julia uses multiple-dispatch capabilities to merge names automatically and will indicate (with a warning) if something went wrong or names have unresolvable collisions on types. As a small example of this feature consider the following small import example:","category":"page"},{"location":"lib/methods/","page":"Exported methods","title":"Exported methods","text":"import ReactiveMP: mean as mean_from_reactivemp\nimport Distributions: mean as mean_from_distributions\nimport BayesBase: mean as mean_from_bayes_base","category":"page"},{"location":"lib/methods/","page":"Exported methods","title":"Exported methods","text":"mean_from_reactivemp === mean_from_distributions","category":"page"},{"location":"lib/methods/","page":"Exported methods","title":"Exported methods","text":"mean_from_reactivemp === mean_from_bayes_base","category":"page"},{"location":"lib/methods/","page":"Exported methods","title":"Exported methods","text":"Even though we import mean function from different packages they actually refer to the same object. Worth noting that this is not always the case - Julia will print a warning in case it finds unresolvable conflicts and usage of such functions will be disallowed unless user import them specifically. Read more about this in the section of the Julia's documentation.","category":"page"},{"location":"lib/methods/","page":"Exported methods","title":"Exported methods","text":"# It is easier to let Julia resolve names automatically\n# Julia will not overwrite `mean` that is coming from both packages\nusing ReactiveMP, Distributions, BayesBase, ExponentialFamily","category":"page"},{"location":"lib/methods/","page":"Exported methods","title":"Exported methods","text":"mean(Normal(0.0, 1.0)) # `Normal` is an object from `Distributions.jl`","category":"page"},{"location":"lib/methods/","page":"Exported methods","title":"Exported methods","text":"mean(NormalMeanVariance(0.0, 1.0)) # `NormalMeanVariance` is an object from `ReactiveMP.jl`","category":"page"},{"location":"lib/methods/#lib-list-methods","page":"Exported methods","title":"List of available methods","text":"","category":"section"},{"location":"lib/methods/","page":"Exported methods","title":"Exported methods","text":"Below you can find a list of exported methods from ReactiveMP.jl. All methods (even private) can be always accessed with ReactiveMP. prefix, e.g ReactiveMP.mean.","category":"page"},{"location":"lib/methods/","page":"Exported methods","title":"Exported methods","text":"note: Note\nSome exported names are (for legacy reasons) intended for private usage only. As a result some of these methods do not have a proper associated documentation with them. We constantly improve ReactiveMP.jl library and continue to add better documentation for many exported methods, but a small portion of these methods could be removed from this list in the future.","category":"page"},{"location":"lib/methods/","page":"Exported methods","title":"Exported methods","text":"using ReactiveMP #hide\nforeach(println, names(ReactiveMP))","category":"page"},{"location":"#ReactiveMP.jl","page":"Introduction","title":"ReactiveMP.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Julia package for reactive message passing Bayesian inference engine on a factor graph.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nThis package exports only an inference engine, for the full ecosystem with convenient model and constraints specification we refer user to the RxInfer.jl package and its documentation.","category":"page"},{"location":"#Examples-and-tutorials","page":"Introduction","title":"Examples and tutorials","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Tutorials and examples are available in the RxInfer documentation.","category":"page"},{"location":"#Table-of-Contents","page":"Introduction","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\n  \"lib/message.md\",\n  \"lib/node.md\",\n  \"lib/math.md\",\n  \"extra/contributing.md\"\n]\nDepth = 2","category":"page"},{"location":"#Index","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"lib/algebra/common/#lib-helpers-algebra-common","page":"Algebra utils","title":"Algebra common utilities","text":"","category":"section"},{"location":"lib/algebra/common/#lib-helpers-algebra-diageye","page":"Algebra utils","title":"diageye","text":"","category":"section"},{"location":"lib/algebra/common/","page":"Algebra utils","title":"Algebra utils","text":"diageye","category":"page"},{"location":"lib/algebra/common/#ReactiveMP.diageye","page":"Algebra utils","title":"ReactiveMP.diageye","text":"diageye(::Type{T}, n::Int)\n\nAn alias for the Matrix{T}(I, n, n). Returns a matrix of size n x n with ones (of type T) on the diagonal and zeros everywhere else.\n\n\n\n\n\ndiageye(n::Int)\n\nAn alias for the Matrix{Float64}(I, n, n). Returns a matrix of size n x n with ones (of type Float64) on the diagonal and zeros everywhere else.\n\n\n\n\n\n","category":"function"}]
}
