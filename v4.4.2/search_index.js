var documenterSearchIndex = {"docs":
[{"location":"lib/message/#lib-message","page":"Messages","title":"Messages implementation","text":"","category":"section"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"In the message passing framework, one of the most important concepts is the message. Given a factor graph, messages are arbitrary functions that flow along the edges of the graph and hold information about the part of the graph from which they originate.","category":"page"},{"location":"lib/message/#lib-messages-as-distributions","page":"Messages","title":"Message as a distribution","text":"","category":"section"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"Often, a message can be represented in the form of a probability distribution, as a probability distribution can be matched with its probability density function. The representation of messages as probability distributions is not only for convenience but also for performance reasons. For example, a univariate Gaussian distribution can be parameterized with two numbers, which significantly reduce the amount of information needed to pass along the edges of the graph.","category":"page"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"using StatsPlots, Distributions\n\nplot(Normal(0.0, 1.0), label = \"Univariate Gaussian distribution\", fillalpha = 0.4, fill = 0)","category":"page"},{"location":"lib/message/#lib-message-vmp","page":"Messages","title":"Variational Message Passing","text":"","category":"section"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"The message passing technique is useful for finding the posterior distribution over certain parameters in a model, originating from exact Bayesian inference, which is also known as Belief Propagation. However, the message passing technique can also be used to find approximate solutions to posteriors - a technique known as Variational inference. The ReactiveMP.jl package implements Variational Message Passing since it is a more general form than exact inference, and also because the exact solution can be framed as an approximate solution subject to no constraints. Here are visual schematics of the differences between messages in Belief propagation and Variational inference.","category":"page"},{"location":"lib/message/#lib-belief-propagation-message","page":"Messages","title":"Belief-Propagation (or Sum-Product) message","text":"","category":"section"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"(Image: message) Belief propagation message","category":"page"},{"location":"lib/message/#lib-variational-message","page":"Messages","title":"Variational message","text":"","category":"section"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"(Image: message) Variational message with structured factorisation q(x, y)q(z) assumption","category":"page"},{"location":"lib/message/#Message-type","page":"Messages","title":"Message type","text":"","category":"section"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"All messages are encoded with the type Message. ","category":"page"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"AbstractMessage\nMessage","category":"page"},{"location":"lib/message/#ReactiveMP.AbstractMessage","page":"Messages","title":"ReactiveMP.AbstractMessage","text":"An abstract supertype for all concrete message types.\n\n\n\n\n\n","category":"type"},{"location":"lib/message/#ReactiveMP.Message","page":"Messages","title":"ReactiveMP.Message","text":"Message(data, is_clamped, is_initial, addons)\n\nAn implementation of a message in variational message passing framework.\n\nArguments\n\ndata::D: message always holds some data object associated with it, which is usually a probability distribution, but can also be an arbitrary function\nis_clamped::Bool, specifies if this message was the result of constant computations (e.g. clamped constants)\nis_initial::Bool, specifies if this message was used for initialization\naddons::A, specifies the addons of the message, which may carry extra bits of information, e.g. debug information, memory, etc.\n\nExample\n\njulia> distribution = Gamma(10.0, 2.0)\nDistributions.Gamma{Float64}(α=10.0, θ=2.0)\n\njulia> message = Message(distribution, false, true, nothing)\nMessage(Distributions.Gamma{Float64}(α=10.0, θ=2.0))\n\njulia> mean(message) \n20.0\n\njulia> getdata(message)\nDistributions.Gamma{Float64}(α=10.0, θ=2.0)\n\njulia> is_clamped(message)\nfalse\n\njulia> is_initial(message)\ntrue\n\n\n\n\n\n\n","category":"type"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"From an implementation point a view the Message structure does nothing but hold some data object and redirects most of the statistical related functions to that data object.  However, this object is used extensively in Julia's multiple dispatch.  Our implementation also uses extra is_initial and is_clamped fields to determine if product of two messages results in is_initial or is_clamped posterior marginal. The final field contains the addons. These contain additional information on top of the functional form of the distribution, such as its scaling or computation history.","category":"page"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"ReactiveMP.getdata(message::Message)\nReactiveMP.is_clamped(message::Message)\nReactiveMP.is_initial(message::Message)\nReactiveMP.getaddons(message::Message)\nReactiveMP.as_message","category":"page"},{"location":"lib/message/#ReactiveMP.getdata-Tuple{Message}","page":"Messages","title":"ReactiveMP.getdata","text":"getdata(message::Message)\n\nReturns data associated with the message.\n\n\n\n\n\n","category":"method"},{"location":"lib/message/#ReactiveMP.is_clamped-Tuple{Message}","page":"Messages","title":"ReactiveMP.is_clamped","text":"is_clamped(message::Message)\n\nChecks if message is clamped or not.\n\n\n\n\n\n","category":"method"},{"location":"lib/message/#ReactiveMP.is_initial-Tuple{Message}","page":"Messages","title":"ReactiveMP.is_initial","text":"is_initial(message::Message)\n\nChecks if message is initial or not.\n\n\n\n\n\n","category":"method"},{"location":"lib/message/#ReactiveMP.getaddons-Tuple{Message}","page":"Messages","title":"ReactiveMP.getaddons","text":"getaddons(message::Message)\n\nReturns addons associated with the message.\n\n\n\n\n\n","category":"method"},{"location":"lib/message/#ReactiveMP.as_message","page":"Messages","title":"ReactiveMP.as_message","text":"as_message(::AbstractMessage)\n\nA function that converts an abstract message to an instance of Message.\n\n\n\n\n\n","category":"function"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"using ReactiveMP, BayesBase, ExponentialFamily\n\ndistribution = ExponentialFamily.NormalMeanPrecision(0.0, 1.0)\nmessage      = Message(distribution, false, true, nothing)","category":"page"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"mean(message), precision(message)","category":"page"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"logpdf(message, 1.0)","category":"page"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"is_clamped(message), is_initial(message)","category":"page"},{"location":"lib/message/#lib-messages-product","page":"Messages","title":"Product of messages","text":"","category":"section"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"In message passing framework, in order to compute a posterior we must compute a normalized product of two messages. For this purpose the ReactiveMP.jl uses the multiply_messages function, which internally uses the prod function defined in BayesBase.jl with various product strategies. We refer an interested reader to the documentation of the  BayesBase.jl package for more information.","category":"page"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"ReactiveMP.multiply_messages\nReactiveMP.messages_prod_fn","category":"page"},{"location":"lib/message/#ReactiveMP.multiply_messages","page":"Messages","title":"ReactiveMP.multiply_messages","text":"multiply_messages(prod_strategy, left::Message, right::Message)\n\nMultiplies two messages left and right using a given product strategy prod_strategy. Returns a new message with the result of the multiplication. Note that the resulting message is not necessarily normalized.\n\n\n\n\n\n","category":"function"},{"location":"lib/message/#ReactiveMP.messages_prod_fn","page":"Messages","title":"ReactiveMP.messages_prod_fn","text":"messages_prod_fn(strategy, prod_constraint, form_constraint, form_check_strategy)\n\nReturns a suitable prod computation function for a given strategy and constraints\n\n\n\n\n\n","category":"function"},{"location":"lib/message/#lib-messages-deferred","page":"Messages","title":"Deferred messages","text":"","category":"section"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"ReactiveMP.DeferredMessage","category":"page"},{"location":"lib/message/#ReactiveMP.DeferredMessage","page":"Messages","title":"ReactiveMP.DeferredMessage","text":"A special type of a message, for which the actual message is not computed immediately, but is computed later on demand (potentially never). To compute and get the actual message, one needs to call the as_message method.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/ar/#lib-nodes-ar","page":"Autoregressive","title":"Autoregressive node","text":"","category":"section"},{"location":"lib/nodes/ar/","page":"Autoregressive","title":"Autoregressive","text":"ReactiveMP.ar_unit\nReactiveMP.ar_slice","category":"page"},{"location":"lib/nodes/ar/#ReactiveMP.ar_unit","page":"Autoregressive","title":"ReactiveMP.ar_unit","text":"ar_unit(::T, order)\n\nReturns [ 1.0, 0.0 ... 0.0 ] with length equal to order in case if T is Multivariate, and 1.0 in case if T is Univariate\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/ar/#ReactiveMP.ar_slice","page":"Autoregressive","title":"ReactiveMP.ar_slice","text":"ar_slice(::T, array, ranges...)\n\nReturns array[ranges...] in case if T is Multivariate, and first(array[ranges...]) in case if T is Univariate\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/delta/#lib-nodes-delta","page":"Delta","title":"Delta node","text":"","category":"section"},{"location":"lib/nodes/delta/","page":"Delta","title":"Delta","text":"ReactiveMP.DeltaMeta\nReactiveMP.ManyOf\nReactiveMP.Linearization\nReactiveMP.local_linearization\nReactiveMP.smoothRTS\nReactiveMP.Unscented\nReactiveMP.sigma_points_weights\nReactiveMP.CVIApproximationDeltaFnRuleLayout\nReactiveMP.log_approximate\nReactiveMP.ForwardDiffGrad\nReactiveMP.UT\nReactiveMP.UnscentedTransform\nReactiveMP.ProdCVI\nReactiveMP.CVI\nReactiveMP.CVIProjection\nReactiveMP.cvi_setup!\nReactiveMP.cvi_update!\nReactiveMP.DeltaFnDefaultRuleLayout\nReactiveMP.DeltaFnDefaultKnownInverseRuleLayout","category":"page"},{"location":"lib/nodes/delta/#ReactiveMP.DeltaMeta","page":"Delta","title":"ReactiveMP.DeltaMeta","text":"DeltaMeta(method = ..., [ inverse = ... ])\n\nDeltaMeta structure specifies the approximation method for the outbound messages in the DeltaFn node. \n\nArguments\n\nmethod: required, the approximation method, currently supported methods are Linearization, Unscented and CVI.\ninverse: optional, if no inverse provided, the backward rule will be computed based on RTS (Petersen et al. 2018; On Approximate Delta Gaussian Message Passing on Factor Graphs)\n\nIs is also possible to pass the AbstractApproximationMethod to the meta of the delta node directly. In this case inverse is set to nothing.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/delta/#ReactiveMP.ManyOf","page":"Delta","title":"ReactiveMP.ManyOf","text":"Some nodes use IndexedInterface, ManyOf structure reflects a collection of marginals from the collection of IndexedInterfaces. @rule macro  also treats ManyOf specially.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/delta/#ReactiveMP.Linearization","page":"Delta","title":"ReactiveMP.Linearization","text":"The Linearization structure defines the approximation method of the Delta and Flow factor nodes.  This method performs a local linearization of f around expansion point x.\n\nThe Linearization structure with default parameters can be constructed as Linearization().\n\nThe Linearization structure is used inside the DeltaMeta or FlowMeta structures and can be included as:\n\n    y ~ f(x) where { meta = DeltaMeta(method = Linearization()) }\n    # or\n    y ~ Flow(x) where { meta = FlowMeta(flowmodel, Linearization()) }\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/delta/#ReactiveMP.local_linearization","page":"Delta","title":"ReactiveMP.local_linearization","text":"local_linearization(g, x)\n\nReturns linear components (a, b) for the function g at the point x.\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/delta/#ReactiveMP.smoothRTS","page":"Delta","title":"ReactiveMP.smoothRTS","text":"RTS smoother update for inbound marginal; based on (Petersen et al. 2018; On Approximate Delta Gaussian Message Passing on Factor Graphs)\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/delta/#ReactiveMP.Unscented","page":"Delta","title":"ReactiveMP.Unscented","text":"The Unscented structure defines the approximation method of the Delta and Flow factor nodes.  More specifically, it contains the hyperparameters used for sigma points computation.\n\nArguments\n\nα: Spread parameter for unscented transform #1\nβ: Algorithm parameter for incorporating prior information on the (non-Gaussian) distribution of Delta node input\nκ: Spread parameter for unscented transform #2\ne: Internal cache\n\nThe Unscented structure with default parameters can be constructed as Unscented().\n\nThe Unscented structure is used inside the DeltaMeta or FlowMeta structure and can be included as: \n\n    y ~ f(x) where { meta = DeltaMeta(method = Unscented()) }\n    # or\n    y ~ Flow(x) where { meta = FlowMeta(flowmodel, Unscented()) }\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/delta/#ReactiveMP.sigma_points_weights","page":"Delta","title":"ReactiveMP.sigma_points_weights","text":"Return the sigma points and weights for a Gaussian distribution\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/delta/#ReactiveMP.CVIApproximationDeltaFnRuleLayout","page":"Delta","title":"ReactiveMP.CVIApproximationDeltaFnRuleLayout","text":"CVIApproximationDeltaFnRuleLayout\n\nCustom rule layout for the Delta node in case of the CVI approximation method:\n\nLayout\n\nIn order to compute:\n\nq_out: mirrors the posterior marginal on the out edge\nq_ins: uses inbound message on the out edge and all inbound messages on the ins edges\nm_out: uses the joint over the ins edges\nm_in_k: uses the inbound message on the in_k edge and q_ins\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/delta/#ReactiveMP.log_approximate","page":"Delta","title":"ReactiveMP.log_approximate","text":"This function calculates the log of the Gauss-laguerre integral by making use of the log of the integrable function.     ln ( ∫ exp(-x)f(x) dx )      ≈ ln ( ∑ wi * f(xi) )      = ln ( ∑ exp( ln(wi) + logf(xi) ) )     = ln ( ∑ exp( yi ) )     = max(yi) + ln ( ∑ exp( yi - max(yi) ) )     where we make use of the numerically stable log-sum-exp trick: https://en.wikipedia.org/wiki/LogSumExp\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/delta/#ReactiveMP.ForwardDiffGrad","page":"Delta","title":"ReactiveMP.ForwardDiffGrad","text":"ForwardDiffGrad(chunk_size::Int)\n\nThe auto-differentiation backend for the CVI procedure. Uses the ForwardDiff library to compute gradients/derivatives. If chunk_size is not specified then uses the heuristic from ForwardDiff, which is type-unstable.\n\nnote: Note\nThe ForwardDiff.jl must be added to the current Julia environment.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/delta/#ReactiveMP.UT","page":"Delta","title":"ReactiveMP.UT","text":"An alias for the Unscented approximation method.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/delta/#ReactiveMP.UnscentedTransform","page":"Delta","title":"ReactiveMP.UnscentedTransform","text":"An alias for the Unscented approximation method.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/delta/#ReactiveMP.ProdCVI","page":"Delta","title":"ReactiveMP.ProdCVI","text":"ProdCVI\n\nThe ProdCVI structure defines the approximation method hyperparameters of the prod(approximation::CVI, logp::F, dist). This method performs an approximation of the product of the dist and logp with Stochastic Variational message passing (SVMP-CVI) (See Probabilistic programming with stochastic variational message passing).\n\nnote: Note\nProdCVI is deprecated in favor of CVIProjection.\n\nArguments\n\nrng: random number generator\nn_samples: number of samples to use for statistics approximation\nn_iterations: number of iteration for the natural parameters gradient optimization\nopt: optimizer, which will be used to perform the natural parameters gradient optimization step\ngrad: optional, defaults to ForwardDiffGrad(), structure to select how the gradient and the hessian will be computed\nn_gradpoints: optional, defaults to 1, number of points to estimate gradient of the likelihood (dist*logp)\nenforce_proper_messages: optional, defaults to true, ensures that a message, computed towards the inbound edges, is a proper distribution, must be of type Val(true)/Val(false)\nwarn: optional, defaults to true, enables or disables warnings related to the optimization steps\n\nnote: Note\nn_gradpoints option is ignored in the Gaussian case\n\nnote: Note\nAdding the Optimisers.jl in your Julia environment enables additional optimizers from the Optimisers.jl for the CVI approximation method. Adding the DiffResults in your Julia environment enables faster gradient computations in case if all inputs are of the Gaussian type.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/delta/#ReactiveMP.CVI","page":"Delta","title":"ReactiveMP.CVI","text":"Alias for the ProdCVI method. See help for ProdCVI\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/delta/#ReactiveMP.CVIProjection","page":"Delta","title":"ReactiveMP.CVIProjection","text":"CVIProjection(; parameters...)\n\nA structure representing the parameters for the Conjugate Variational Inference (CVI) projection method.  This structure is a subtype of AbstractApproximationMethod and is used to configure the settings for CVI.\n\nnote: Note\nThe CVIProjection method requires ExponentialFamilyProjection package installed in the current environment.\n\nParameters\n\nrng::R: The random number generator used for sampling. Default is Random.MersenneTwister(42).\nmarginalsamples::S: The number of samples used for approximating marginal distributions. Default is 10.\noutsamples::S: The number of samples used for approximating output message distributions. Default is 100.\nprjparams::P: Parameters for the exponential family projection. Default is nothing, in which case it will use ExponentialFamilyProjection.DefaultProjectionParameters().\n\nnote: Note\nThe CVIProjection method is an experimental enhancement of the now-deprecated CVI, offering better stability and improved accuracy.  Note that the parameters of this structure, as well as their defaults, are subject to change during the experimentation phase.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/delta/#ReactiveMP.cvi_setup!","page":"Delta","title":"ReactiveMP.cvi_setup!","text":"cvi_setup!(opt, λ)\n\nInitialises the given optimiser for the CVI procedure given the structure of λ. Returns a tuple of the optimiser and the optimiser state.\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/delta/#ReactiveMP.cvi_update!","page":"Delta","title":"ReactiveMP.cvi_update!","text":"cvi_update!(tuple_of_opt_and_state, new_λ, λ, ∇)\n\nUses the optimiser, its state and the gradient ∇ to change the trainable parameters in the λ. Modifies the optimiser state and and store the output in the newλ. Returns a tuple of the optimiser and the newλ.\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/delta/#ReactiveMP.DeltaFnDefaultRuleLayout","page":"Delta","title":"ReactiveMP.DeltaFnDefaultRuleLayout","text":"DeltaFnDefaultRuleLayout\n\nDefault rule layout for the Delta node:\n\nLayout\n\nIn order to compute:\n\nq_out: mirrors the posterior marginal on the out edge\nq_ins: uses inbound message on the out edge and all inbound messages on the ins edges\nm_out: uses all inbound messages on the ins edges\nm_in_k: uses the inbound message on the in_k edge and q_ins\n\nSee also: ReactiveMP.DeltaFnDefaultKnownInverseRuleLayout\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/delta/#ReactiveMP.DeltaFnDefaultKnownInverseRuleLayout","page":"Delta","title":"ReactiveMP.DeltaFnDefaultKnownInverseRuleLayout","text":"DeltaFnDefaultKnownInverseRuleLayout\n\nDefault rule layout for the Delta node:\n\nLayout\n\nIn order to compute:\n\nq_out: mirrors the posterior marginal on the out edge (same as the DeltaFnDefaultRuleLayout)\nq_ins: uses inbound message on the out edge and all inbound messages on the ins edges (same as the DeltaFnDefaultRuleLayout)\nm_out: uses all inbound messages on the ins edges (same as the DeltaFnDefaultRuleLayout)\nm_in_k: uses inbound message on the out edge and inbound messages on the ins edges except k\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/#lib-node","page":"Factor nodes","title":"Nodes implementation","text":"","category":"section"},{"location":"lib/nodes/","page":"Factor nodes","title":"Factor nodes","text":"In the message passing framework, one of the most important concepts is a factor node. A factor node represents a local function in a factorised representation of a generative model.","category":"page"},{"location":"lib/nodes/","page":"Factor nodes","title":"Factor nodes","text":"@node\nReactiveMP.FactorNode\nReactiveMP.FactorNodeLocalMarginal\nReactiveMP.NodeInterface\nReactiveMP.IndexedNodeInterface\nReactiveMP.messagein\nReactiveMP.messageout\nReactiveMP.tag\nReactiveMP.name\nReactiveMP.interfaces\nReactiveMP.getvariable\nReactiveMP.inputinterfaces\nReactiveMP.alias_interface\nReactiveMP.collect_factorisation\nReactiveMP.collect_pipeline\nReactiveMP.collect_meta\nReactiveMP.default_meta\nReactiveMP.as_node_symbol","category":"page"},{"location":"lib/nodes/#ReactiveMP.@node","page":"Factor nodes","title":"ReactiveMP.@node","text":"@node(fformtype, sdtype, interfaces_list)\n\n@node macro creates a node for a fformtype type object. To obtain a list of predefined nodes use ?is_predefined_node.\n\nArguments\n\nfformtype: Either an existing type identifier, e.g. Normal or a function type identifier, e.g. typeof(+)\nsdtype: Either Stochastic or Deterministic. Defines the type of the functional relationship\ninterfaces_list: Defines a fixed list of edges of a factor node, by convention the first element should be out. Example: [ out, mean, variance ]\n\nNote: interfaces_list must not include names that contain _ symbol in them, as it is reserved to identify joint posteriors around the node object.\n\nExamples\n\n\nstruct MyNormalDistribution\n    mean :: Float64\n    var  :: Float64\nend\n\n@node MyNormalDistribution Stochastic [ out, mean, var ]\n\n\n@node typeof(+) Deterministic [ out, in1, in2 ]\n\nList of available nodes\n\nSee ?is_predefined_node.\n\n\n\n\n\n","category":"macro"},{"location":"lib/nodes/#ReactiveMP.FactorNode","page":"Factor nodes","title":"ReactiveMP.FactorNode","text":"GenericFactorNode(functionalform, interfaces)\n\nGeneric factor node object that represents a factor node with a given functionalform and interfaces.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/#ReactiveMP.FactorNodeLocalMarginal","page":"Factor nodes","title":"ReactiveMP.FactorNodeLocalMarginal","text":"FactorNodeLocalMarginal\n\nThis object represents local marginals for some specific factor node. The local marginal can be joint in case of structured factorisation. Local to factor node marginal also can be shared with a corresponding marginal of some random variable.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/#ReactiveMP.NodeInterface","page":"Factor nodes","title":"ReactiveMP.NodeInterface","text":"NodeInterface\n\nNodeInterface object represents a single node-variable connection.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/#ReactiveMP.IndexedNodeInterface","page":"Factor nodes","title":"ReactiveMP.IndexedNodeInterface","text":"IndexedNodeInterface\n\nIndexedNodeInterface object represents a repetative node-variable connection. Used in cases when a node may connect to a different number of random variables with the same name, e.g. means and precisions of a Gaussian Mixture node.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/#ReactiveMP.messagein","page":"Factor nodes","title":"ReactiveMP.messagein","text":"messagein(interface)\n\nReturns an inbound messages stream from the given interface.\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/#ReactiveMP.messageout","page":"Factor nodes","title":"ReactiveMP.messageout","text":"messageout(interface)\n\nReturns an outbound messages stream from the given interface.\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/#ReactiveMP.tag","page":"Factor nodes","title":"ReactiveMP.tag","text":"tag(interface)\n\nReturns a tag of the interface in the form of Val{ name(interface) }. The major difference between tag and name is that it is possible to dispath on interface's tag in message computation rule.\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/#ReactiveMP.name","page":"Factor nodes","title":"ReactiveMP.name","text":"name(interface)\n\nReturns a name of the interface.\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/#ReactiveMP.interfaces","page":"Factor nodes","title":"ReactiveMP.interfaces","text":"interfaces(fform)\n\nReturns a Val object with a tuple of interface names for a given factor node type. Returns nothing for unknown functional form.\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/#ReactiveMP.getvariable","page":"Factor nodes","title":"ReactiveMP.getvariable","text":"getvariable(interface)\n\nReturns a variable connected to the given interface.\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/#ReactiveMP.inputinterfaces","page":"Factor nodes","title":"ReactiveMP.inputinterfaces","text":"inputinterfaces(fform)\n\nSimilar to interfaces, but returns a Val object with a tuple of input interface names for a given factor node type. Returns nothing for unknown functional form.\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/#ReactiveMP.alias_interface","page":"Factor nodes","title":"ReactiveMP.alias_interface","text":"alias_interface(factor_type, index, name)\n\nConverts the given name to a correct interface name for a given factor node type and index.\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/#ReactiveMP.collect_factorisation","page":"Factor nodes","title":"ReactiveMP.collect_factorisation","text":"collect_factorisation(nodetype, factorisation)\n\nThis function converts given factorisation to a correct internal factorisation representation for a given node.\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/#ReactiveMP.collect_pipeline","page":"Factor nodes","title":"ReactiveMP.collect_pipeline","text":"collect_pipeline(nodetype, pipeline)\n\nThis function converts given pipeline to a correct internal pipeline representation for a factor given node.\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/#ReactiveMP.collect_meta","page":"Factor nodes","title":"ReactiveMP.collect_meta","text":"collect_meta(nodetype, meta)\n\nThis function converts given meta object to a correct internal meta representation for a given node. Fallbacks to default_meta in case if meta is nothing.\n\nSee also: default_meta, FactorNode\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/#ReactiveMP.default_meta","page":"Factor nodes","title":"ReactiveMP.default_meta","text":"default_meta(nodetype)\n\nReturns default meta object for a given node type.\n\nSee also: collect_meta, FactorNode\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/#ReactiveMP.as_node_symbol","page":"Factor nodes","title":"ReactiveMP.as_node_symbol","text":"as_node_symbol(type)\n\nReturns a symbol associated with a node type.\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/#lib-custom-node","page":"Factor nodes","title":"Adding a custom node","text":"","category":"section"},{"location":"lib/nodes/","page":"Factor nodes","title":"Factor nodes","text":"ReactiveMP.jl exports the @node macro that allows for quick definition of a factor node with a fixed number of edges. The example application can be the following:","category":"page"},{"location":"lib/nodes/","page":"Factor nodes","title":"Factor nodes","text":"struct MyNewCustomNode end\n\n@node MyNewCustomNode   Stochastic         [ x, y, (z, aliases = [ d ] ) ]\n#     ^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^      ^^^^^^^^^^^\n#     Node's tag/name   Node's type        A fixed set of edges\n#                       Another possible   The very first edge (in this example `x`) is considered\n#                       value is           to be the output of the node\n#                       `Deterministic`    - Edges can have aliases, e.g. `z` can be both `z` or `d`","category":"page"},{"location":"lib/nodes/","page":"Factor nodes","title":"Factor nodes","text":"This expression registers a new node that can be used with the inference engine.  Note, however, that the @node macro does not generate any message passing update rules. These must be defined using the @rule macro. ","category":"page"},{"location":"lib/nodes/#lib-node-types","page":"Factor nodes","title":"Node types","text":"","category":"section"},{"location":"lib/nodes/","page":"Factor nodes","title":"Factor nodes","text":"We distinguish different types of factor nodes in order to have better control over Bethe Free Energy computation. Each factor node has either the Deterministic or Stochastic functional form type.","category":"page"},{"location":"lib/nodes/","page":"Factor nodes","title":"Factor nodes","text":"Deterministic\nStochastic\nisdeterministic\nisstochastic\nsdtype","category":"page"},{"location":"lib/nodes/#ReactiveMP.Deterministic","page":"Factor nodes","title":"ReactiveMP.Deterministic","text":"Deterministic\n\nDeterministic object used to parametrize factor node object with determinstic type of relationship between variables.\n\nSee also: Stochastic, isdeterministic, isstochastic, sdtype\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/#ReactiveMP.Stochastic","page":"Factor nodes","title":"ReactiveMP.Stochastic","text":"Stochastic\n\nStochastic object used to parametrize factor node object with stochastic type of relationship between variables.\n\nSee also: Deterministic, isdeterministic, isstochastic, sdtype\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/#ReactiveMP.isdeterministic","page":"Factor nodes","title":"ReactiveMP.isdeterministic","text":"isdeterministic(node)\n\nFunction used to check if factor node object is deterministic or not. Returns true or false.\n\nSee also: Deterministic, Stochastic, isstochastic, sdtype\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/#ReactiveMP.isstochastic","page":"Factor nodes","title":"ReactiveMP.isstochastic","text":"isstochastic(node)\n\nFunction used to check if factor node object is stochastic or not. Returns true or false.\n\nSee also: Deterministic, Stochastic, isdeterministic, sdtype\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/#ReactiveMP.sdtype","page":"Factor nodes","title":"ReactiveMP.sdtype","text":"sdtype(object)\n\nReturns either Deterministic or Stochastic for a given object (if defined).\n\nSee also: Deterministic, Stochastic, isdeterministic, isstochastic\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/","page":"Factor nodes","title":"Factor nodes","text":"using ReactiveMP, BayesBase, Distributions, ExponentialFamily","category":"page"},{"location":"lib/nodes/","page":"Factor nodes","title":"Factor nodes","text":"For example the + node has the Deterministic type:","category":"page"},{"location":"lib/nodes/","page":"Factor nodes","title":"Factor nodes","text":"println(\"Is `+` node deterministic: \", isdeterministic(sdtype(+)))\nprintln(\"Is `+` node stochastic: \", isstochastic(sdtype(+)))\nnothing #hide","category":"page"},{"location":"lib/nodes/","page":"Factor nodes","title":"Factor nodes","text":"On the other hand, the Bernoulli node has the Stochastic type:","category":"page"},{"location":"lib/nodes/","page":"Factor nodes","title":"Factor nodes","text":"println(\"Is `Bernoulli` node deterministic: \", isdeterministic(sdtype(Bernoulli)))\nprintln(\"Is `Bernoulli` node stochastic: \", isstochastic(sdtype(Bernoulli)))\nnothing #hide","category":"page"},{"location":"lib/nodes/","page":"Factor nodes","title":"Factor nodes","text":"To get an actual instance of the type object we use sdtype function:","category":"page"},{"location":"lib/nodes/","page":"Factor nodes","title":"Factor nodes","text":"println(\"sdtype() of `+` node is \", sdtype(+))\nprintln(\"sdtype() of `Bernoulli` node is \", sdtype(Bernoulli))\nnothing #hide","category":"page"},{"location":"lib/nodes/#lib-node-functional-dependencies-pipeline","page":"Factor nodes","title":"Node functional dependencies pipeline","text":"","category":"section"},{"location":"lib/nodes/","page":"Factor nodes","title":"Factor nodes","text":"The generic implementation of factor nodes in ReactiveMP supports custom functional dependency pipelines. Briefly, the functional dependencies pipeline defines what dependencies are need to compute a single message. As an example, consider the belief-propagation message update equation for a factor node f with three edges: x, y and z:","category":"page"},{"location":"lib/nodes/","page":"Factor nodes","title":"Factor nodes","text":"mu(x) = int mu(y) mu(z) f(x y z) mathrmdy mathrmdz","category":"page"},{"location":"lib/nodes/","page":"Factor nodes","title":"Factor nodes","text":"Here we see that in the standard setting for the belief-propagation message out of edge x, we need only messages from the edges y and z. In contrast, consider the variational message update rule equation with mean-field assumption:","category":"page"},{"location":"lib/nodes/","page":"Factor nodes","title":"Factor nodes","text":"mu(x) = exp int q(y) q(z) log f(x y z) mathrmdy mathrmdz","category":"page"},{"location":"lib/nodes/","page":"Factor nodes","title":"Factor nodes","text":"We see that in this setting, we do not need messages mu(y) and mu(z), but only the marginals q(y) and q(z). The purpose of a functional dependencies pipeline is to determine functional dependencies (a set of messages or marginals) that are needed to compute a single message. By default, ReactiveMP.jl uses so-called DefaultFunctionalDependencies that correctly implements belief-propagation and variational message passing schemes (including both mean-field and structured factorisations). The full list of built-in pipelines is presented below:","category":"page"},{"location":"lib/nodes/","page":"Factor nodes","title":"Factor nodes","text":"ReactiveMP.DefaultFunctionalDependencies\nReactiveMP.RequireMessageFunctionalDependencies\nReactiveMP.RequireMarginalFunctionalDependencies\nReactiveMP.RequireEverythingFunctionalDependencies","category":"page"},{"location":"lib/nodes/#ReactiveMP.DefaultFunctionalDependencies","page":"Factor nodes","title":"ReactiveMP.DefaultFunctionalDependencies","text":"DefaultFunctionalDependencies\n\nThis functional dependencies translate directly to a regular variational message passing scheme.  In order to compute a message out of some interface, this strategy requires messages from interfaces within the same cluster and marginals over other clusters.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/#ReactiveMP.RequireMessageFunctionalDependencies","page":"Factor nodes","title":"ReactiveMP.RequireMessageFunctionalDependencies","text":"RequireMessageFunctionalDependencies(specifications::NamedTuple)\nRequireMessageFunctionalDependencies(; specifications...)\n\nThe same as DefaultFunctionalDependencies, but in order to compute a message out of some edge also requires the inbound message on the this edge.\n\nThe specification parameter is a named tuple that contains the names of the edges and their initial messages.  When a name is present in the named tuple, that indicates that the computation of the outbound message on the same edge must use the inbound message. If nothing is passed as a value in the named tuple, the initial message is not set. Note that the construction allows passing keyword argument to the constructor  instead of using NamedTuple directly.\n\nRequireMessageFunctionalDependencies(μ = vague(NormalMeanPrecision),     τ = nothing)\n                                     # ^^^                               ^^^\n                                     # request 'inbound' for 'x'         we may do the same for 'τ',\n                                     # and initialise with `vague(...)`  but here we skip initialisation\n\nSee also: ReactiveMP.DefaultFunctionalDependencies, ReactiveMP.RequireMarginalFunctionalDependencies, ReactiveMP.RequireEverythingFunctionalDependencies\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/#ReactiveMP.RequireMarginalFunctionalDependencies","page":"Factor nodes","title":"ReactiveMP.RequireMarginalFunctionalDependencies","text":"RequireMarginalFunctionalDependencies(specifications::NamedTuple)\nRequireMarginalFunctionalDependencies(; specifications...)\n\nThe same as DefaultFunctionalDependencies, but in order to compute a message out of some edge also requires the marginal on the this edge.\n\nThe specification parameter is a named tuple that contains the names of the edges and their initial marginals.  When a name is present in the named tuple, that indicates that the computation of the outbound message on the same edge must use the marginal on this edge. If nothing is passed as a value in the named tuple, the initial marginal is not set. Note that the construction allows passing keyword argument to the constructor  instead of using NamedTuple directly.\n\nRequireMarginalFunctionalDependencies(μ = vague(NormalMeanPrecision),     τ = nothing)\n                                     # ^^^                               ^^^\n                                     # request 'marginal' for 'x'        we may do the same for 'τ',\n                                     # and initialise with `vague(...)`  but here we skip initialisation\n\nSee also: ReactiveMP.DefaultFunctionalDependencies, ReactiveMP.RequireMessageFunctionalDependencies, ReactiveMP.RequireEverythingFunctionalDependencies\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/#ReactiveMP.RequireEverythingFunctionalDependencies","page":"Factor nodes","title":"ReactiveMP.RequireEverythingFunctionalDependencies","text":"RequireEverythingFunctionalDependencies\n\nThis pipeline specifies that in order to compute a message of some edge update rules request everything that is available locally. This includes all inbound messages (including on the same edge) and marginals over all local edge-clusters (this may or may not include marginals on single edges, depends on the local factorisation constraint).\n\nSee also: DefaultFunctionalDependencies, RequireMessageFunctionalDependencies, RequireMarginalFunctionalDependencies\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/#lib-node-traits","page":"Factor nodes","title":"Node traits","text":"","category":"section"},{"location":"lib/nodes/","page":"Factor nodes","title":"Factor nodes","text":"Each factor node has to define the ReactiveMP.is_predefined_node trait function and to specify a ReactiveMP.PredefinedNodeFunctionalForm  singleton as a return object. By default ReactiveMP.is_predefined_node returns ReactiveMP.UndefinedNodeFunctionalForm.  Objects that do not specify this property correctly cannot be used in model specification.","category":"page"},{"location":"lib/nodes/","page":"Factor nodes","title":"Factor nodes","text":"note: Note\n@node macro does that automatically","category":"page"},{"location":"lib/nodes/","page":"Factor nodes","title":"Factor nodes","text":"ReactiveMP.PredefinedNodeFunctionalForm\nReactiveMP.UndefinedNodeFunctionalForm\nReactiveMP.is_predefined_node","category":"page"},{"location":"lib/nodes/#ReactiveMP.PredefinedNodeFunctionalForm","page":"Factor nodes","title":"ReactiveMP.PredefinedNodeFunctionalForm","text":"PredefinedNodeFunctionalForm\n\nTrait specification for an object that has been marked as a valid factor node with the @node macro.\n\nSee also: ReactiveMP.is_predefined_node, ReactiveMP.UndefinedNodeFunctionalForm\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/#ReactiveMP.UndefinedNodeFunctionalForm","page":"Factor nodes","title":"ReactiveMP.UndefinedNodeFunctionalForm","text":"UndefinedNodeFunctionalForm\n\nTrait specification for an object that has not been marked as a factor node with the @node macro. Note that it does not necessarily mean that the object is not a valid factor node, but rather that it has not been marked as such. The ReactiveMP inference engine support arbitrary deterministic function as factor nodes, but they require manual specification of the approximation method.\n\nSee also: ReactiveMP.is_predefined_node, ReactiveMP.PredefinedNodeFunctionalForm\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/#ReactiveMP.is_predefined_node","page":"Factor nodes","title":"ReactiveMP.is_predefined_node","text":"is_predefined_node(object)\n\nDetermines if the object has been marked as a factor node with the @node macro. Returns either PredefinedNodeFunctionalForm() or UndefinedNodeFunctionalForm().\n\nSee also: ReactiveMP.PredefinedNodeFunctionalForm, ReactiveMP.UndefinedNodeFunctionalForm\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/#lib-node-pipelines","page":"Factor nodes","title":"Node pipelines","text":"","category":"section"},{"location":"lib/nodes/","page":"Factor nodes","title":"Factor nodes","text":"ReactiveMP.AbstractPipelineStage\nReactiveMP.apply_pipeline_stage\nReactiveMP.EmptyPipelineStage\nReactiveMP.CompositePipelineStage\nReactiveMP.LoggerPipelineStage\nReactiveMP.DiscontinuePipelineStage\nReactiveMP.AsyncPipelineStage\nReactiveMP.ScheduleOnPipelineStage\nReactiveMP.schedule_updates","category":"page"},{"location":"lib/nodes/#ReactiveMP.AbstractPipelineStage","page":"Factor nodes","title":"ReactiveMP.AbstractPipelineStage","text":"AbstractPipelineStage\n\nAn abstract type for all custom pipelines stages\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/#ReactiveMP.apply_pipeline_stage","page":"Factor nodes","title":"ReactiveMP.apply_pipeline_stage","text":"apply_pipeline_stage(stage, factornode, tag, stream)\n\nApplies a given pipeline stage to the stream argument given factornode and tag of an edge.\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/#ReactiveMP.EmptyPipelineStage","page":"Factor nodes","title":"ReactiveMP.EmptyPipelineStage","text":"EmptyPipelineStage <: AbstractPipelineStage\n\nDummy empty pipeline stage that does not modify the original pipeline.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/#ReactiveMP.CompositePipelineStage","page":"Factor nodes","title":"ReactiveMP.CompositePipelineStage","text":"CompositePipelineStage{T} <: AbstractPipelineStage\n\nComposite pipeline stage that consists of multiple inner pipeline stages \n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/#ReactiveMP.LoggerPipelineStage","page":"Factor nodes","title":"ReactiveMP.LoggerPipelineStage","text":"LoggerPipelineStage <: AbstractPipelineStage\n\nLogs all updates from stream into output\n\nArguments\n\noutput: (optional), an output stream used to print log statements\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/#ReactiveMP.DiscontinuePipelineStage","page":"Factor nodes","title":"ReactiveMP.DiscontinuePipelineStage","text":"DiscontinuePipelineStage <: AbstractPipelineStage\n\nApplies the discontinue() operator from Rocket.jl library to the given pipeline\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/#ReactiveMP.AsyncPipelineStage","page":"Factor nodes","title":"ReactiveMP.AsyncPipelineStage","text":"AsyncPipelineStage <: AbstractPipelineStage\n\nApplies the async() operator from Rocket.jl library to the given pipeline\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/#ReactiveMP.ScheduleOnPipelineStage","page":"Factor nodes","title":"ReactiveMP.ScheduleOnPipelineStage","text":"ScheduleOnPipelineStage{S} <: AbstractPipelineStage\n\nApplies the schedule_on() operator from Rocket.jl library to the given pipeline with a provided scheduler\n\nArguments\n\nscheduler: scheduler to schedule updates on. Must be compatible with Rocket.jl library and schedule_on() operator.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/#ReactiveMP.schedule_updates","page":"Factor nodes","title":"ReactiveMP.schedule_updates","text":"schedule_updates(variables...; pipeline_stage = ScheduleOnPipelineStage(PendingScheduler()))\n\nSchedules posterior marginal updates for given variables using stage. By default creates ScheduleOnPipelineStage with PendingScheduler() from Rocket.jl library. Returns a scheduler with release! method available to release all scheduled updates.\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/#lib-predefined-nodes","page":"Factor nodes","title":"List of predefined factor node","text":"","category":"section"},{"location":"lib/nodes/","page":"Factor nodes","title":"Factor nodes","text":"To quickly check the list of all predefined factor nodes, call ?ReactiveMP.is_predefined_node or Base.doc(ReactiveMP.is_predefined_node).","category":"page"},{"location":"lib/nodes/","page":"Factor nodes","title":"Factor nodes","text":"?ReactiveMP.is_predefined_node","category":"page"},{"location":"lib/nodes/","page":"Factor nodes","title":"Factor nodes","text":"using ReactiveMP, Markdown\nMarkdown.parse(string(Base.doc(Base.Docs.Binding(ReactiveMP, :is_predefined_node))))","category":"page"},{"location":"lib/nodes/logical/#lib-nodes-logical","page":"Logical","title":"Logical operations","text":"","category":"section"},{"location":"lib/nodes/logical/","page":"Logical","title":"Logical","text":"ReactiveMP.AND\nReactiveMP.OR\nReactiveMP.IMPLY\nReactiveMP.NOT","category":"page"},{"location":"lib/nodes/logical/#ReactiveMP.AND","page":"Logical","title":"ReactiveMP.AND","text":"AND node implements logic AND function (conjuction) that can be desribed by the followsing table: | in1  in2 | out | |  0    0  |  0  | |  0    1  |  0  | |  1    0  |  0  | |  1    1  |  1  |\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/logical/#ReactiveMP.OR","page":"Logical","title":"ReactiveMP.OR","text":"OR node implements logic OR function (disjunction) that can be desribed by the followsing table: | in1  in2 | out | |  0    0  |  0  | |  0    1  |  1  | |  1    0  |  1  | |  1    1  |  1  |\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/logical/#ReactiveMP.IMPLY","page":"Logical","title":"ReactiveMP.IMPLY","text":"IMPY node implements implication function that can be desribed by the followsing table: | in1  in2 | out | |  0    0  |  1  | |  0    1  |  1  | |  1    0  |  0  | |  1    1  |  1  |\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/logical/#ReactiveMP.NOT","page":"Logical","title":"ReactiveMP.NOT","text":"NOT node implements negation function that can be desribed by the followsing table: | in  | out | |  0  |  1  | |  1  |  0  |\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/ctransition/#lib-nodes-ctransition","page":"Continuous transition","title":"Continous transition node","text":"","category":"section"},{"location":"lib/nodes/ctransition/","page":"Continuous transition","title":"Continuous transition","text":"ReactiveMP.ContinuousTransition\nReactiveMP.ContinuousTransitionMeta\nReactiveMP.ctcompanion_matrix","category":"page"},{"location":"lib/nodes/ctransition/#ReactiveMP.ContinuousTransition","page":"Continuous transition","title":"ReactiveMP.ContinuousTransition","text":"The functional form of the ContinuousTransition node is given by: y ~ Normal(K(a) * x, W⁻¹)\n\nThis node transforms an m-dimensional vector x into an n-dimensional vector y via a linear (or nonlinear) transformation with a n×m-dimensional matrix A that is constructed from a vector a via a transformation K(a). ContinuousTransition node is primarily used in two regimes:\n\nWhen no structure on A is specified:\n\ntransformation = a -> reshape(a, 2, 2)\n...\na ~ MvNormalMeanCovariance(zeros(2), Diagonal(ones(2)))\ny ~ ContinuousTransition(x, a, W) where {meta = CTMeta(transformation)}\n...\n\nWhen some structure if A is known:\n\ntransformation = a -> [cos(a[1]) -sin(a[1]); sin(a[1]) cos(a[1])]\n...\na ~ MvNormalMeanCovariance(zeros(1), Diagonal(ones(1)))\ny ~ ContinuousTransition(x, a, W) where {meta = CTMeta(transformation)}\n...\n\nTo construct the matrix A, the elements of a are reshaped into A according to the transformation function provided in the meta. If you intend to use univariate Gaussian distributions, use it as a vector of length 1, e.g.a ~ MvNormalMeanCovariance([0.0], [1.;])`.\n\nCheck ContinuousTransitionMeta for more details on how to specify the transformation function that must return a matrix.\n\ny ~ ContinuousTransition(x, a, W) where {meta = ContinuousTransitionMeta(transformation)}\n\nInterfaces:\n\ny - n-dimensional output of the ContinuousTransition node.\nx - m-dimensional input of the ContinuousTransition node.\na - any-dimensional vector that casts into the matrix A. \nW - n×n-dimensional precision matrix used to soften the transition and perform variational message passing.\n\nNote that you can set W to a fixed value or put a prior on it to control the amount of jitter.\n\nThe ContinuousTransition node support two factorizations:\n\nMean-field factorization:\n\n@constraints begin\n    q(y, x, a, W) = q(y)q(x)q(a)q(W)\nend\n\nStructured factorization:\n\n@constraints begin\n    q(y, x, a, W) = q(y, x)q(a)q(W)\nend\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/ctransition/#ReactiveMP.ContinuousTransitionMeta","page":"Continuous transition","title":"ReactiveMP.ContinuousTransitionMeta","text":"ContinuousTransitionMeta is used as a metadata flag in ContinuousTransition to define the transformation function for constructing the matrix A from vector a.\n\nContinuousTransitionMeta requires a transformation function and the length of vector a, which acts as an expansion point for approximating the transformation linearly. If transformation appears to be linear, then no approximation is performed.\n\nConstructors:\n\nContinuousTransitionMeta(transformation::Function, â::Vector{<:Real}): Constructs a ContinuousTransitionMeta struct with the transformation function and allocated basis vectors.\n\nFields:\n\nf:  Represents the transformation function that transforms vector a into matrix A\n\nThe ContinuousTransitionMeta struct plays a pivotal role in defining how the vector a is transformed into the matrix A, thus influencing the behavior of the ContinuousTransition node.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/ctransition/#ReactiveMP.ctcompanion_matrix","page":"Continuous transition","title":"ReactiveMP.ctcompanion_matrix","text":"`ctcompanion_matrix` casts a vector `a` into a matrix `A` by means of linearization of the transformation function `f` around the expansion point `a0`.\n\n\n\n\n\n","category":"function"},{"location":"lib/algebra/#lib-helpers-algebra-common","page":"Algebra utils","title":"Algebra common utilities","text":"","category":"section"},{"location":"lib/algebra/#lib-helpers-algebra-diageye","page":"Algebra utils","title":"diageye","text":"","category":"section"},{"location":"lib/algebra/","page":"Algebra utils","title":"Algebra utils","text":"diageye\nReactiveMP.CompanionMatrix\nReactiveMP.PermutationMatrix\nReactiveMP.StandardBasisVector\nReactiveMP.GammaShapeLikelihood\nReactiveMP.ImportanceSamplingApproximation\nReactiveMP.mul_inplace!\nReactiveMP.negate_inplace!\nReactiveMP.mul_trace\nReactiveMP.rank1update\nReactiveMP.v_a_vT\nReactiveMP.powerset\nReactiveMP.besselmod","category":"page"},{"location":"lib/algebra/#ReactiveMP.diageye","page":"Algebra utils","title":"ReactiveMP.diageye","text":"diageye(::Type{T}, n::Int)\n\nAn alias for the Matrix{T}(I, n, n). Returns a matrix of size n x n with ones (of type T) on the diagonal and zeros everywhere else.\n\n\n\n\n\ndiageye(n::Int)\n\nAn alias for the Matrix{Float64}(I, n, n). Returns a matrix of size n x n with ones (of type Float64) on the diagonal and zeros everywhere else.\n\n\n\n\n\n","category":"function"},{"location":"lib/algebra/#ReactiveMP.CompanionMatrix","page":"Algebra utils","title":"ReactiveMP.CompanionMatrix","text":"CompanionMatrix\n\nRepresents a matrix of the following structure:\n\nθ1 θ2 θ3 ... θn-1 θn  1  0  0  ...   0  0   0  1  0  ...   0  0   .  .  .  ...   .  .  .  .  .  ...   .  .  0  0  0  ...   0  0  0  0  0  ...   1  0\n\n\n\n\n\n","category":"type"},{"location":"lib/algebra/#ReactiveMP.PermutationMatrix","page":"Algebra utils","title":"ReactiveMP.PermutationMatrix","text":"PermutationMatrix(ind::Array{T}) creates a permutation matrix with ones at coordinates (k, ind[k]) for k = 1:length(ind).\n\nA permutation matrix represents a matrix containing only zeros and ones, which basically permutes the vector or matrix it is multiplied with. These matrices A are constrained by:\n\n    A_ij = 0 1\n    _i A_ij = 1\n    _j A_ij = 1\n\nAn example is the 3-dimensional permutation matrix\n\nA = beginbmatrix 1  0  0  0  0  1  1  0  0 endbmatrix\n\n\n\n\n\n","category":"type"},{"location":"lib/algebra/#ReactiveMP.StandardBasisVector","page":"Algebra utils","title":"ReactiveMP.StandardBasisVector","text":"StandardBasisVector{T, len, ind}(scale::T)\n\nStandardBasisVector creates a standard Cartesian basis vector of zeros of length len with a single element scale at index ind.\n\nAn example is the 3-dimensional standard basis vector for the first dimension\n\ne = beginbmatrix 1  0  0 endbmatrix\n\nWhich can be constructed by calling e = StandardBasisVector(3, 1, 1)\n\n\n\n\n\n","category":"type"},{"location":"lib/algebra/#ReactiveMP.GammaShapeLikelihood","page":"Algebra utils","title":"ReactiveMP.GammaShapeLikelihood","text":"ν(x) ∝ exp(p*β*x - p*logГ(x)) ≡ exp(γ*x - p*logГ(x))\n\n\n\n\n\n","category":"type"},{"location":"lib/algebra/#ReactiveMP.ImportanceSamplingApproximation","page":"Algebra utils","title":"ReactiveMP.ImportanceSamplingApproximation","text":"ImportanceSamplingApproximation\n\nThis structure stores all information needed to perform an importance sampling procedure and provides convenient functions to generate samples and weights to approximate expectations\n\nFields\n\nrng: random number generator objects\nnsamples: number of samples generated by default\n\n\n\n\n\n","category":"type"},{"location":"lib/algebra/#ReactiveMP.mul_inplace!","page":"Algebra utils","title":"ReactiveMP.mul_inplace!","text":"mul_inplace!(alpha, A)\n\nReturns alpha * A, modifying and reusing A storage if possible.\n\nSee also: negate_inplace!\n\n\n\n\n\n","category":"function"},{"location":"lib/algebra/#ReactiveMP.negate_inplace!","page":"Algebra utils","title":"ReactiveMP.negate_inplace!","text":"negate_inplace!(A)\n\nReturns -A, modifying and reusing A storage if possible.\n\nSee also: mul_inplace!\n\n\n\n\n\n","category":"function"},{"location":"lib/algebra/#ReactiveMP.mul_trace","page":"Algebra utils","title":"ReactiveMP.mul_trace","text":"mul_trace(A, B)\n\nComputes tr(A * B) without allocating A * B.\n\n\n\n\n\n","category":"function"},{"location":"lib/algebra/#ReactiveMP.rank1update","page":"Algebra utils","title":"ReactiveMP.rank1update","text":"rank1update(A, x)\nrank1update(A, x, y)\n\nHelper function for A + x * y'. Uses optimised BLAS version for AbstractFloats and fallbacks to a generic implementation in case of differentiation\n\n\n\n\n\n","category":"function"},{"location":"lib/algebra/#ReactiveMP.v_a_vT","page":"Algebra utils","title":"ReactiveMP.v_a_vT","text":"v_a_vT(v, a)\n\nComputes vav^T efficiently.\n\n\n\n\n\n","category":"function"},{"location":"lib/algebra/#ReactiveMP.powerset","page":"Algebra utils","title":"ReactiveMP.powerset","text":"powerset(iterator)\n\nComputes the set of all possible sets of the iterator.\n\n\n\n\n\n","category":"function"},{"location":"lib/algebra/#ReactiveMP.besselmod","page":"Algebra utils","title":"ReactiveMP.besselmod","text":"Modified-bessel function of second kind\n\nmx, vx : mean and variance of the random variable x  my, vy : mean and variance of the random variable y  rho    : correlation coefficient\n\n\n\n\n\n","category":"function"},{"location":"extra/contributing/#Contribution-guidelines","page":"Contributing","title":"Contribution guidelines","text":"","category":"section"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"We welcome all possible contributors. This page details the some of the guidelines that should be followed when contributing to this package.","category":"page"},{"location":"extra/contributing/#Reporting-bugs","page":"Contributing","title":"Reporting bugs","text":"","category":"section"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"We track bugs using GitHub issues. We encourage you to write complete, specific, reproducible bug reports. Mention the versions of Julia and ReactiveMP for which you observe unexpected behavior. Please provide a concise description of the problem and complement it with code snippets, test cases, screenshots, tracebacks or any other information that you consider relevant. This will help us to replicate the problem and narrow the search space for solutions.","category":"page"},{"location":"extra/contributing/#Suggesting-features","page":"Contributing","title":"Suggesting features","text":"","category":"section"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"We welcome new feature proposals. However, before submitting a feature request, consider a few things:","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"Does the feature require changes in the core ReactiveMP.jl code? If it doesn't (for example, you would like to add a factor node for a particular application), you can add local extensions in your script/notebook or consider making a separate repository for your extensions.\nIf you would like to add an implementation of a feature that changes a lot in the core ReactiveMP.jl code, please open an issue on GitHub and describe your proposal first. This will allow us to discuss your proposal with you before you invest your time in implementing something that may be difficult to merge later on.","category":"page"},{"location":"extra/contributing/#Contributing-code","page":"Contributing","title":"Contributing code","text":"","category":"section"},{"location":"extra/contributing/#Installing-ReactiveMP","page":"Contributing","title":"Installing ReactiveMP","text":"","category":"section"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"We suggest that you use the dev command from the new Julia package manager to install ReactiveMP.jl for development purposes. To work on your fork of ReactiveMP.jl, use your fork's URL address in the dev command, for example:","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"] dev git@github.com:your_username/ReactiveMP.jl.git","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"The dev command clones ReactiveMP.jl to ~/.julia/dev/ReactiveMP. All local changes to ReactiveMP code will be reflected in imported code.","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"note: Note\nIt is also might be useful to install Revise.jl package as it allows you to modify code and use the changes without restarting Julia.","category":"page"},{"location":"extra/contributing/#Committing-code","page":"Contributing","title":"Committing code","text":"","category":"section"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"We use the standard GitHub Flow workflow where all contributions are added through pull requests. In order to contribute, first fork the repository, then commit your contributions to your fork, and then create a pull request on the master branch of the ReactiveMP.jl repository.","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"Before opening a pull request, please make sure that all tests pass without failing! All demos (can be found in /demo/ directory) and benchmarks (can be found in /benchmark/ directory) have to run without errors as well.","category":"page"},{"location":"extra/contributing/#Style-conventions","page":"Contributing","title":"Style conventions","text":"","category":"section"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"note: Note\nReactiveMP.jl repository contains scripts to automatically format code according to our guidelines. Use make format command to fix code style. This command overwrites files.","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"We use default Julia style guide. We list here a few important points and our modifications to the Julia style guide:","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"Use 4 spaces for indentation\nType names use UpperCamelCase. For example: AbstractFactorNode, RandomVariable, etc..\nFunction names are lowercase with underscores, when necessary. For example: activate!, randomvar, etc..\nVariable names and function arguments use snake_case\nThe name of a method that modifies its argument(s) must end in !","category":"page"},{"location":"extra/contributing/#Unit-tests","page":"Contributing","title":"Unit tests","text":"","category":"section"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"We use the test-driven development (TDD) methodology for ReactiveMP.jl development. The test coverage should be as complete as possible. Please make sure that you write tests for each piece of code that you want to add.","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"All unit tests are located in the /test/ directory. The /test/ directory follows the structure of the /src/ directory. Each test file should have following filename format: test_*.jl. Some tests are also present in jldoctest docs annotations directly in the source code. See Julia's documentation about doctests.","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"The tests can be evaluated by running following command in the Julia REPL:","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"] test ReactiveMP","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"In addition tests can be evaluated by running following command in the ReactiveMP root directory:","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"make test","category":"page"},{"location":"extra/contributing/#Fixes-to-external-libraries","page":"Contributing","title":"Fixes to external libraries","text":"","category":"section"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"If a bug has been discovered in an external dependencies of the ReactiveMP.jl it is the best to open an issue  directly in the dependency's github repository. You use can use the fixes.jl file for hot-fixes before  a new release of the broken dependecy is available.","category":"page"},{"location":"extra/contributing/#Makefile","page":"Contributing","title":"Makefile","text":"","category":"section"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"ReactiveMP.jl uses Makefile for most common operations:","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"make help: Shows help snippet\nmake test: Run tests, supports extra arguments\nmake test test_args=\"distributions:normal_mean_variance\" would run tests only from distributions/test_normal_mean_variance.jl\nmake test test_args=\"distributions:normal_mean_variance models:lgssm\" would run tests both from distributions/test_normal_mean_variance.jl and models/test_lgssm.jl\nmake docs: Compile documentation\nmake benchmark: Run simple benchmark\nmake lint: Check codestyle\nmake format: Check and fix codestyle ","category":"page"},{"location":"lib/nodes/flow/#lib-nodes-flow","page":"Flow","title":"Flow node","text":"","category":"section"},{"location":"lib/nodes/flow/","page":"Flow","title":"Flow","text":"See also Flow tutorial for a comprehensive guide on using flows in RxInfer.jl.","category":"page"},{"location":"lib/nodes/flow/","page":"Flow","title":"Flow","text":"PlanarFlow\nRadialFlow\nFlowModel\nCompiledFlowModel\ncompile\nAdditiveCouplingLayer\nInputLayer\nPermutationLayer\nFlowMeta","category":"page"},{"location":"lib/nodes/flow/#ReactiveMP.PlanarFlow","page":"Flow","title":"ReactiveMP.PlanarFlow","text":"The PlanarFlow function is defined as\n\nf(bfx) = bfx + bfu tanh(bfw^top bfx + b)\n\nwith input and output dimension D. Here bfxin mathbbR^D represents the input of the function. Furthermore bfuin mathbbR^D, bfwin mathbbR^D and binmathbbR represent the parameters of the function. The function contracts and expands the input space. \n\nThis function has been introduced in:\n\nRezende, Danilo, and Shakir Mohamed. \"Variational inference with normalizing flows.\" International conference on machine learning. PMLR, 2015.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/flow/#ReactiveMP.RadialFlow","page":"Flow","title":"ReactiveMP.RadialFlow","text":"The RadialFlow function is defined as\n\nf(bfx) = bfx + fracbeta(bfz - bfz_0)alpha + bfz - bfz_0\n\nwith input and output dimension D. Here bfxin mathbbR^D represents the input of the function. Furthermore bfz_0in mathbbR^D, alphain mathbbR and betainmathbbR represent the parameters of the function. The function contracts and expands the input space. \n\nThis function has been introduced in:\n\nRezende, Danilo, and Shakir Mohamed. \"Variational inference with normalizing flows.\" International conference on machine learning. PMLR, 2015.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/flow/#ReactiveMP.FlowModel","page":"Flow","title":"ReactiveMP.FlowModel","text":"The FlowModel structure is the most generic type of Flow model, in which the layers are not constrained to be of a specific type. The FlowModel structure contains the input dimensionality and a tuple of layers and can be constructed as FlowModel( dim, (layer1, layer2, ...) ).\n\nNote: this model can be specialized by constraining the types of layers. This potentially allows for more efficient specialized methods that can deal with specifics of these layers, such as triangular jacobian matrices.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/flow/#ReactiveMP.CompiledFlowModel","page":"Flow","title":"ReactiveMP.CompiledFlowModel","text":"The CompiledFlowModel structure is the most generic type of compiled Flow model, in which the layers are not constrained to be of a specific type. The FlowModel structure contains the input dimension and a tuple of compiled layers. Do not manually create a CompiledFlowModel! Instead create a FlowModel first and compile it with compile(model::FlowModel). This will make sure that all layers/mappings are configured with the proper dimensionality and with randomly sampled parameters. Alternatively, if you would like to pass your own parameters, call compile(model::FlowModel, params::Vector).\n\nNote: this model can be specialized by constraining the types of layers. This potentially allows for more efficient specialized methods that can deal with specifics of these layers, such as triangular jacobian matrices.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/flow/#ReactiveMP.compile","page":"Flow","title":"ReactiveMP.compile","text":"compile() compiles a model by setting its parameters. It randomly sets parameter values in the layers and flows such that inference in the model can be obtained.\n\nInput arguments\n\nmodel::FlowModel - a model of which the dimensionality of its layers/flows has been initialized, but its parameters have not been set.\n\nReturn arguments\n\n::CompiledFlowModel - a compiled model with set parameters, such that it can be used for processing data.\n\n\n\n\n\ncompile(model::FlowModel, params::Vector) lets you initialize a model model with a vector of parameters params.\n\nInput arguments\n\nmodel::FlowModel - a model of which the dimensionality of its layers/flows has been initialized, but its parameters have not been set.\nparams::Vector   - a vector of parameters with which the model should be compiled.\n\nReturn arguments\n\n::CompiledFlowModel - a compiled model with set parameters, such that it can be used for processing data.\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/flow/#ReactiveMP.AdditiveCouplingLayer","page":"Flow","title":"ReactiveMP.AdditiveCouplingLayer","text":"The additive coupling layer specifies an invertible function bfy = g(bfx) following the specific structure (for the mapping g mathbbR^2 rightarrow mathbbR^2):\n\n    beginalign\n        y_1 = x_1 \n        y_2 = x_2 + f(x_1)\n    endalign\n\nwhere f(cdot) denotes an arbitrary function with mapping f mathbbR rightarrow mathbbR. This function can be chosen arbitrarily complex. Non-linear functions (neural networks) are often chosen to model complex relationships. From the definition of the model, invertibility can be easily achieved as\n\n    beginalign\n        x_1 = y_1 \n        x_2 = y_2 - f(y_1)\n    endalign\n\nThe current implementation only allows for the mapping g mathbbR^2 rightarrow mathbbR^2, although this layer can be generalized for arbitrary input dimensions.\n\nAdditiveCouplingLayer(f <: AbstractCouplingFlow) creates the layer structure with function f.\n\nExample\n\nf = PlanarFlow()\nlayer = AdditiveCouplingLayer(f)\n\nThis layer structure has been introduced in:\n\nDinh, Laurent, David Krueger, and Yoshua Bengio. \"Nice: Non-linear independent components estimation.\" arXiv preprint arXiv:1410.8516 (2014).\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/flow/#ReactiveMP.InputLayer","page":"Flow","title":"ReactiveMP.InputLayer","text":"The input layer specifies the input dimension to a flow model.\n\nlayer = InputLayer(3)\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/flow/#ReactiveMP.PermutationLayer","page":"Flow","title":"ReactiveMP.PermutationLayer","text":"The permutation layer specifies an invertible mapping bfy = g(bfx) = Pbfx where P is a permutation matrix.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/flow/#ReactiveMP.FlowMeta","page":"Flow","title":"ReactiveMP.FlowMeta","text":"The FlowMeta structure contains the meta data of the Flow factor node. More specifically, it contains the model of the Flow factor node. The FlowMeta structure can be constructed as FlowMeta(model). Make sure that the flow model has been compiled.\n\nThe FlowMeta structure is required for the Flow factor node and can be included with the Flow node as: y ~ Flow(x) where { meta = FlowMeta(...) }\n\n\n\n\n\n","category":"type"},{"location":"lib/marginal/#lib-marginal","page":"Marginals","title":"Marginal implementation","text":"","category":"section"},{"location":"lib/marginal/#Marginal-type","page":"Marginals","title":"Marginal type","text":"","category":"section"},{"location":"lib/marginal/","page":"Marginals","title":"Marginals","text":"All marginals are encoded with the type Marginal. ","category":"page"},{"location":"lib/marginal/","page":"Marginals","title":"Marginals","text":"Marginal","category":"page"},{"location":"lib/marginal/#ReactiveMP.Marginal","page":"Marginals","title":"ReactiveMP.Marginal","text":"Marginal(data, is_clamped, is_initial, addons)\n\nAn implementation of a marginal in variational message passing framework.\n\nArguments\n\ndata::D: marginal always holds some data object associated with it, which is usually a probability distribution\nis_clamped::Bool, specifies if this marginal was the result of constant computations (e.g. clamped constants)\nis_initial::Bool, specifies if this marginal was used for initialization\naddons::A, specifies the addons of the marginal, which may carry extra bits of information, e.g. debug information, memory, etc.\n\nExample\n\njulia> distribution = Gamma(10.0, 2.0)\nDistributions.Gamma{Float64}(α=10.0, θ=2.0)\n\njulia> message = Marginal(distribution, false, true, nothing)\nMarginal(Distributions.Gamma{Float64}(α=10.0, θ=2.0))\n\njulia> mean(message) \n20.0\n\njulia> getdata(message)\nDistributions.Gamma{Float64}(α=10.0, θ=2.0)\n\njulia> is_clamped(message)\nfalse\n\njulia> is_initial(message)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"lib/marginal/","page":"Marginals","title":"Marginals","text":"From an implementation point a view the Marginal structure does nothing but hold some data object and redirects most of the statistical related functions to that data object. However, this object is used extensively in Julia's multiple dispatch. ","category":"page"},{"location":"lib/marginal/","page":"Marginals","title":"Marginals","text":"ReactiveMP.getdata(marginal::Marginal)\nReactiveMP.is_clamped(marginal::Marginal)\nReactiveMP.is_initial(marginal::Marginal)\nReactiveMP.getaddons(marginal::Marginal)\nReactiveMP.as_marginal\nReactiveMP.to_marginal","category":"page"},{"location":"lib/marginal/#ReactiveMP.getdata-Tuple{Marginal}","page":"Marginals","title":"ReactiveMP.getdata","text":"getdata(marginal::Marginal)\n\nReturns data associated with the marginal.\n\n\n\n\n\n","category":"method"},{"location":"lib/marginal/#ReactiveMP.is_clamped-Tuple{Marginal}","page":"Marginals","title":"ReactiveMP.is_clamped","text":"is_clamped(marginal::Marginal)\n\nChecks if marginal is clamped or not.\n\nSee also: is_initial\n\n\n\n\n\n","category":"method"},{"location":"lib/marginal/#ReactiveMP.is_initial-Tuple{Marginal}","page":"Marginals","title":"ReactiveMP.is_initial","text":"is_initial(marginal::Marginal)\n\nChecks if marginal is initial or not.\n\nSee also: is_clamped\n\n\n\n\n\n","category":"method"},{"location":"lib/marginal/#ReactiveMP.getaddons-Tuple{Marginal}","page":"Marginals","title":"ReactiveMP.getaddons","text":"getaddons(marginal::Marginal)\n\nReturns addons associated with the marginal.\n\n\n\n\n\n","category":"method"},{"location":"lib/marginal/#ReactiveMP.as_marginal","page":"Marginals","title":"ReactiveMP.as_marginal","text":"as_marginal(any)\n\nA function that converts any to an instance of Marginal.\n\n\n\n\n\n","category":"function"},{"location":"lib/marginal/#ReactiveMP.to_marginal","page":"Marginals","title":"ReactiveMP.to_marginal","text":"to_marginal(any)\n\nTransforms an input to a proper marginal distribution. Called inside as_marginal. Some nodes do not use Distributions.jl, but instead implement their own equivalents for messages for better efficiency. Effectively to_marginal is needed to convert internal effective implementation to a user-friendly equivalent (e.g. from Distributions.jl). By default does nothing and returns its input, but some nodes may override this behaviour (see for example Wishart and InverseWishart).\n\nNote: This function is a part of the private API and is not intended to be used outside of the ReactiveMP package.\n\n\n\n\n\n","category":"function"},{"location":"lib/marginal/","page":"Marginals","title":"Marginals","text":"using ReactiveMP, BayesBase, ExponentialFamily\n\ndistribution  = ExponentialFamily.NormalMeanPrecision(0.0, 1.0)\nmarginal      = Marginal(distribution, false, true, nothing)","category":"page"},{"location":"lib/marginal/","page":"Marginals","title":"Marginals","text":"mean(marginal), precision(marginal)","category":"page"},{"location":"lib/marginal/","page":"Marginals","title":"Marginals","text":"logpdf(marginal, 1.0)","category":"page"},{"location":"lib/marginal/","page":"Marginals","title":"Marginals","text":"is_clamped(marginal), is_initial(marginal)","category":"page"},{"location":"extra/extensions/#Extensions-and-interaction-with-the-Julia-ecosystem","page":"Extensions","title":"Extensions and interaction with the Julia ecosystem","text":"","category":"section"},{"location":"extra/extensions/","page":"Extensions","title":"Extensions","text":"ReactiveMP.jl exports extra functionality if other Julia packages are loaded in the same environment.","category":"page"},{"location":"extra/extensions/#Optimisers.jl","page":"Extensions","title":"Optimisers.jl","text":"","category":"section"},{"location":"extra/extensions/","page":"Extensions","title":"Extensions","text":"The Optimizers.jl package defines many standard gradient-based optimisation rules, and tools for applying them to deeply nested models. The optimizers defined in the Optimziers.jl are compatible with the CVI approximation method.","category":"page"},{"location":"extra/extensions/#DiffResults.jl-(loaded-automatically-with-the-ForwardDiff.jl)","page":"Extensions","title":"DiffResults.jl (loaded automatically with the ForwardDiff.jl)","text":"","category":"section"},{"location":"extra/extensions/","page":"Extensions","title":"Extensions","text":"The DiffResults.jl provides the DiffResult type, which can be passed to in-place differentiation methods instead of an output buffer. If loaded in the current Julia session enables faster derivatives with the ForwardDiffGrad option in the CVI approximation method (in the Gaussian case).","category":"page"},{"location":"custom/custom-functional-form/#custom-functional-form","page":"Custom functional form","title":"Custom Functional Form Specification","text":"","category":"section"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"In a nutshell, functional form constraints defines a function that approximates the product of colliding messages and computes posterior marginal that can be used later on during the inference procedure. An important part of the functional forms constraint implementation is the prod function in the BayesBase package. For example, if we refer to our CustomFunctionalForm as to f we can see the whole functional form constraints pipeline as:","category":"page"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"q(x) = fleft(fracoverrightarrowmu(x)overleftarrowmu(x)int overrightarrowmu(x)overleftarrowmu(x) mathrmdxright)","category":"page"},{"location":"custom/custom-functional-form/#Interface","page":"Custom functional form","title":"Interface","text":"","category":"section"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"ReactiveMP.jl, however, uses some extra utility functions to define functional form constraint behaviour. Here we briefly describe all utility function. If you are only interested in the concrete example, you may directly head to the Custom Functional Form example at the end of this section.","category":"page"},{"location":"custom/custom-functional-form/#Abstract-super-type","page":"Custom functional form","title":"Abstract super type","text":"","category":"section"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"AbstractFormConstraint\nUnspecifiedFormConstraint\nCompositeFormConstraint\nReactiveMP.preprocess_form_constraints","category":"page"},{"location":"custom/custom-functional-form/#ReactiveMP.AbstractFormConstraint","page":"Custom functional form","title":"ReactiveMP.AbstractFormConstraint","text":"AbstractFormConstraint\n\nEvery functional form constraint is a subtype of AbstractFormConstraint abstract type.\n\nNote: this is not strictly necessary, but it makes automatic dispatch easier and compatible with the CompositeFormConstraint.\n\n\n\n\n\n","category":"type"},{"location":"custom/custom-functional-form/#ReactiveMP.UnspecifiedFormConstraint","page":"Custom functional form","title":"ReactiveMP.UnspecifiedFormConstraint","text":"UnspecifiedFormConstraint\n\nOne of the form constraint objects. Does not imply any form constraints and simply returns the same object as receives. However it does not allow DistProduct to be a valid functional form in the inference backend.\n\n\n\n\n\n","category":"type"},{"location":"custom/custom-functional-form/#ReactiveMP.CompositeFormConstraint","page":"Custom functional form","title":"ReactiveMP.CompositeFormConstraint","text":"CompositeFormConstraint\n\nCreates a composite form constraint that applies form constraints in order. The composed form constraints must be compatible and have the exact same form_check_strategy. \n\n\n\n\n\n","category":"type"},{"location":"custom/custom-functional-form/#ReactiveMP.preprocess_form_constraints","page":"Custom functional form","title":"ReactiveMP.preprocess_form_constraints","text":"preprocess_form_constraints(constraints)\n\nThis function preprocesses form constraints and converts the provided objects into a form compatible with ReactiveMP inference backend (if possible).  If a tuple of constraints is passed, it creates a CompositeFormConstraint object. Wraps unknown form constraints into a WrappedFormConstraint object.\n\n\n\n\n\n","category":"function"},{"location":"custom/custom-functional-form/#Form-check-strategy","page":"Custom functional form","title":"Form check strategy","text":"","category":"section"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"Every custom functional form must implement a new method for the default_form_check_strategy function that returns either FormConstraintCheckEach or FormConstraintCheckLast.","category":"page"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"FormConstraintCheckLast: q(x) = f(μ1(x) * μ2(x) * μ3(x))\nFormConstraintCheckEach: q(x) = f(f(μ1(x) * μ2(x)) * μ3(x))","category":"page"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"default_form_check_strategy\nFormConstraintCheckEach\nFormConstraintCheckLast\nFormConstraintCheckPickDefault","category":"page"},{"location":"custom/custom-functional-form/#ReactiveMP.default_form_check_strategy","page":"Custom functional form","title":"ReactiveMP.default_form_check_strategy","text":"default_form_check_strategy(form_constraint)\n\nReturns a default check strategy (e.g. FormConstraintCheckEach or FormConstraintCheckEach) for a given form constraint object.\n\n\n\n\n\n","category":"function"},{"location":"custom/custom-functional-form/#ReactiveMP.FormConstraintCheckEach","page":"Custom functional form","title":"ReactiveMP.FormConstraintCheckEach","text":"FormConstraintCheckEach\n\nThis form constraint check strategy checks functional form of the messages product after each product in an equality chain.  Usually if a variable has been connected to multiple nodes we want to perform multiple prod to obtain a posterior marginal. With this form check strategy constrain_form function will be executed after each subsequent prod function.\n\n\n\n\n\n","category":"type"},{"location":"custom/custom-functional-form/#ReactiveMP.FormConstraintCheckLast","page":"Custom functional form","title":"ReactiveMP.FormConstraintCheckLast","text":"FormConstraintCheckEach\n\nThis form constraint check strategy checks functional form of the last messages product in the equality chain.  Usually if a variable has been connected to multiple nodes we want to perform multiple prod to obtain a posterior marginal. With this form check strategy constrain_form function will be executed only once after all subsequenct prod functions have been executed.\n\n\n\n\n\n","category":"type"},{"location":"custom/custom-functional-form/#ReactiveMP.FormConstraintCheckPickDefault","page":"Custom functional form","title":"ReactiveMP.FormConstraintCheckPickDefault","text":"FormConstraintCheckPickDefault\n\nThis form constraint check strategy simply fallbacks to a default check strategy for a given form constraint. \n\n\n\n\n\n","category":"type"},{"location":"custom/custom-functional-form/#Prod-constraint","page":"Custom functional form","title":"Prod constraint","text":"","category":"section"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"Every custom functional form must implement a new method for the default_prod_constraint function that returns a proper prod_constraint object.","category":"page"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"default_prod_constraint","category":"page"},{"location":"custom/custom-functional-form/#ReactiveMP.default_prod_constraint","page":"Custom functional form","title":"ReactiveMP.default_prod_constraint","text":"default_prod_constraint(form_constraint)\n\nReturns a default prod constraint needed to apply a given form_constraint. For most form constraints this function returns ProdGeneric.\n\n\n\n\n\n","category":"function"},{"location":"custom/custom-functional-form/#Constrain-form,-a.k.a-f","page":"Custom functional form","title":"Constrain form, a.k.a f","text":"","category":"section"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"The main function that a custom functional form must implement, which we referred to as f in the beginning of this section, is the constrain_form function.","category":"page"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"constrain_form","category":"page"},{"location":"custom/custom-functional-form/#ReactiveMP.constrain_form","page":"Custom functional form","title":"ReactiveMP.constrain_form","text":"constrain_form(constraint, something)\n\nThis function applies a given form constraint to a given object. \n\n\n\n\n\n","category":"function"},{"location":"custom/custom-functional-form/#custom-functional-form-example","page":"Custom functional form","title":"Custom Functional Form Example","text":"","category":"section"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"In this demo, we show how to build a custom functional form constraint that is compatible with the ReactiveMP.jl inference backend. An important part of the functional form constraint implementation is the prod function in the BayesBase package. We present a relatively simple use case, which may not be very practical but serves as a straightforward step-by-step guide.","category":"page"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"Assume that we want a specific posterior marginal of some random variable in our model to have a specific Gaussian parameterization, such as mean-precision. Here, how we can achieve this with our custom MeanPrecisionFormConstraint functional form constraint:","category":"page"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"using ReactiveMP, ExponentialFamily, Distributions, BayesBase\n\n# First, we define our functional form structure with no fields\nstruct MeanPrecisionFormConstraint <: AbstractFormConstraint end\n\nReactiveMP.default_form_check_strategy(::MeanPrecisionFormConstraint) = FormConstraintCheckLast()\nReactiveMP.default_prod_constraint(::MeanPrecisionFormConstraint) = GenericProd()\n\nfunction ReactiveMP.constrain_form(::MeanPrecisionFormConstraint, distribution) \n    # This assumes that the given `distribution` object has `mean` and `precision` defined.\n    # These quantities might be approximated using other methods, such as Laplace approximation.\n    m = mean(distribution)      # or approximate with some other method\n    p = precision(distribution) # or approximate with some other method\n    return NormalMeanPrecision(m, p)\nend\n\nfunction ReactiveMP.constrain_form(::MeanPrecisionFormConstraint, distribution::BayesBase.ProductOf)\n    # `ProductOf` is a special case. Read more about this type in the corresponding \n    # documentation section of the `BayesBase` package.\n    # ... \nend\n\nconstraint = ReactiveMP.preprocess_form_constraints(MeanPrecisionFormConstraint())\n\nconstrain_form(constraint, NormalMeanVariance(0, 2))","category":"page"},{"location":"custom/custom-functional-form/#Wrapped-Form-Constraints","page":"Custom functional form","title":"Wrapped Form Constraints","text":"","category":"section"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"Some constraint objects might not be subtypes of AbstractFormConstraint. This can occur, for instance, if the object is defined in a different package or needs to subtype a different abstract type. In such cases, ReactiveMP expects users to pass a WrappedFormConstraint object, which wraps the original object and makes it compatible with the ReactiveMP inference backend. Note that the ReactiveMP.preprocess_form_constraints function automatically wraps all objects that are not subtypes of AbstractFormConstraint.","category":"page"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"Additionally, objects wrapped by WrappedFormConstraints may implement the ReactiveMP.prepare_context function. This function's output will be stored in the WrappedFormConstraints along with the original object. If prepare_context is implemented, the constrain_form function will take three arguments: the original constraint, the context, and the object that needs to be constrained.","category":"page"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"ReactiveMP.WrappedFormConstraint\nReactiveMP.prepare_context\nReactiveMP.constrain_form(::ReactiveMP.WrappedFormConstraint, something)","category":"page"},{"location":"custom/custom-functional-form/#ReactiveMP.WrappedFormConstraint","page":"Custom functional form","title":"ReactiveMP.WrappedFormConstraint","text":"WrappedFormConstraint(constraint, context)\n\nThis is a wrapper for a form constraint object. It allows to pass additional context to the constrain_form function. By default all objects that are not sub-typed from AbstractFormConstraint are wrapped into this object.  Use ReactiveMP.prepare_context to provide an extra context for a given form constraint, that can be reused between multiple constrain_form calls.\n\n\n\n\n\n","category":"type"},{"location":"custom/custom-functional-form/#ReactiveMP.prepare_context","page":"Custom functional form","title":"ReactiveMP.prepare_context","text":"prepare_context(constraint)\n\nThis function prepares a context for a given form constraint. Returns WrappedFormConstraintNoContext if no context is needed (the default behaviour).\n\n\n\n\n\n","category":"function"},{"location":"custom/custom-functional-form/#ReactiveMP.constrain_form-Tuple{ReactiveMP.WrappedFormConstraint, Any}","page":"Custom functional form","title":"ReactiveMP.constrain_form","text":"constrain_form(wrapped::WrappedFormConstraint, something)\n\nThis function unwraps the wrapped object and calls constrain_form function with the provided context. If the context is not provided, simply calls constrain_form with the wrapped constraint. Otherwise passes the context to the constrain_form function as the second argument.\n\n\n\n\n\n","category":"method"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"using ReactiveMP, Distributions, BayesBase, Random\n\n# First, we define our custom form constraint that creates a set of samples\n# Note that this is not a subtype of `AbstractFormConstraint`\nstruct MyCustomSampleListFormConstraint end\n\n# Note that we still need to implement `default_form_check_strategy` and `default_prod_constraint` functions\n#  which are necessary for the `ReactiveMP` inference backend\nReactiveMP.default_form_check_strategy(::MyCustomSampleListFormConstraint) = FormConstraintCheckLast()\nReactiveMP.default_prod_constraint(::MyCustomSampleListFormConstraint) = GenericProd()\n\n# We implement the `prepare_context` function, which returns a random number generator\nfunction ReactiveMP.prepare_context(constraint::MyCustomSampleListFormConstraint)\n    return Random.default_rng()\nend\n\n# We implement the `constrain_form` function, which returns a set of samples\nfunction ReactiveMP.constrain_form(constraint::MyCustomSampleListFormConstraint, context, distribution)\n    return rand(context, distribution, 10)\nend\n\nconstraint = ReactiveMP.preprocess_form_constraints(MyCustomSampleListFormConstraint())\n\nconstrain_form(constraint, Normal(0, 10))","category":"page"},{"location":"custom/custom-addons/#custom-addons","page":"Custom addons","title":"Custom Addons","text":"","category":"section"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"Standard message passing schemes only pass along distributions to other nodes. However, for more advanced usage, there might be a need for passing along additional information in messages and/or marginals. One can for example think of passing along the scaling of the distribution or some information that specifies how the message or marginal was computed, i.e. which messages were used for its computation and which node was preceding it. Another use cases is saving extra debugging information inside messages themselves, e.g. what arguments have been used to compute a message.","category":"page"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"Addons provide a solution here. Basically, addons are structures that contain extra information that are passed along the graph with messages and marginals in a tuple. These addons can be extracted using the getaddons(message/marginal) function. Its usage and operations can differ significantly for each application, yet below gives a concise overview on how to implement them on your own.","category":"page"},{"location":"custom/custom-addons/#Example","page":"Custom addons","title":"Example","text":"","category":"section"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"Suppose that we wish to create an addon that counts the number of computations that preceded some message or marginal. This addon can be created by adding the file src/addons/count.jl and by including it in the ReactiveMP.jl file.","category":"page"},{"location":"custom/custom-addons/#Step-1:-Creating-the-addon-structure","page":"Custom addons","title":"Step 1: Creating the addon structure","text":"","category":"section"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"Let's start by defining our new addon structure. This might seem daunting, but basically only requires us to specify the information that we would like to collect. Just make sure that it is specified as a subtype of AbstractAddon. In our example this becomes:","category":"page"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"struct AddonCount{T} <: AbstractAddon\n    count :: T\nend","category":"page"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"You can add additional fields or functions for improved handling, such as get_count() or show() functions.","category":"page"},{"location":"custom/custom-addons/#Step-2:-Compute-addon-value-after-computing-a-message","page":"Custom addons","title":"Step 2: Compute addon value after computing a message","text":"","category":"section"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"As a second step we need to specify how the addon behaves when a new message is computed in a factor node.  For this purpose we need to implement a specialized version of the message_mapping_addon() function. This function accepts the mapping variables of the factor node and updates the addons by extending the tuple.","category":"page"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"In our example we could write","category":"page"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"# This specification assumes that the default value for addon is `AddonCount(nothing)`\nfunction message_mapping_addon(::AddonCount{Nothing}, mapping, messages, marginals, result, addons)\n\n    # get number of operations of messages\n    message_count = 0\n    for message in messages\n        message_count += getcount(message)\n    end\n\n    # get number of operations of marginals\n    marginal_count = 0\n    for marginal in marginals\n        marginal_count += getcount(marginal)\n    end\n\n    # extend addons with AddonCount() structure\n    return AddonCount(message_count + marginal_count + 1)\nend\n","category":"page"},{"location":"custom/custom-addons/#Step-3:-Computing-products","page":"Custom addons","title":"Step 3: Computing products","text":"","category":"section"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"The goal is to update the AddonCount structure when we multiply 2 messages. As a result, we need to write a function that allows us to define this behaviour. This function is called multiply_addons and accepts 5 arguments. In our example this becomes","category":"page"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"function multiply_addons(left_addon::AddonCount, right_addon::AddonCount, new_dist, left_dist, right_dist)\n    return AddonCount(left_addon.count + right_addon.count + 1)\nend","category":"page"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"here we add the number of operations from the addons that are being multiplied and we add one (for the current operation). we are aware that this is likely not valid for iterative message passing schemes, but it still serves as a nice example. the left_addon and right_addon argument specify the addoncount objects that are being multiplied. corresponding to these addons, there are the distributions left_dist and right_dist, which might contain information for computing the product. the new distribution new_dist ∝ left_dist * right_dist is also passed along for potentially reusing the result of earlier computations.","category":"page"},{"location":"custom/custom-addons/#More-information","page":"Custom addons","title":"More information","text":"","category":"section"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"For more advanced information check the implementation of the log-scale or memory addons.","category":"page"},{"location":"custom/custom-addons/#Built-in-addons","page":"Custom addons","title":"Built-in addons","text":"","category":"section"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"ReactiveMP.AddonDebug","category":"page"},{"location":"custom/custom-addons/#ReactiveMP.AddonDebug","page":"Custom addons","title":"ReactiveMP.AddonDebug","text":"AddonDebug(f :: Function)\n\nThis addon calls the function f over the output of the message mapping and products. The result is expected to be boolean and when returning true, it will throw an error with the debug information. Common applications of this addon are to check for NaNs and Infs in the messages and marginals. \n\nExample\n\ncheckfornans(x) = isnan(x)\ncheckfornans(x::AbstractArray) = any(checkfornans.(x))\ncheckfornans(x::Tuple) = any(checkfornans.(x))\n\naddons = (AddonDebug(dist -> checkfornans(params(dist))),)\n\n\n\n\n\n","category":"type"},{"location":"extra/methods/#lib-using-methods","page":"Exported methods","title":"Using methods from ReactiveMP","text":"","category":"section"},{"location":"extra/methods/","page":"Exported methods","title":"Exported methods","text":"In the Julia programming language (in contrast to Python for example) the most common way of loading a module is:","category":"page"},{"location":"extra/methods/","page":"Exported methods","title":"Exported methods","text":"using ReactiveMP","category":"page"},{"location":"extra/methods/","page":"Exported methods","title":"Exported methods","text":"A nice explanation about how modules/packages work in Julia can be found in the official documentation.","category":"page"},{"location":"extra/methods/","page":"Exported methods","title":"Exported methods","text":"In a nutshell, Julia automatically resolves all name collisions and there is no a lot of benefit of importing specific names, e.g.:","category":"page"},{"location":"extra/methods/","page":"Exported methods","title":"Exported methods","text":"import ReactiveMP: mean","category":"page"},{"location":"extra/methods/","page":"Exported methods","title":"Exported methods","text":"One of the reasons for that is that Julia uses multiple-dispatch capabilities to merge names automatically and will indicate (with a warning) if something went wrong or names have unresolvable collisions on types. As a small example of this feature consider the following small import example:","category":"page"},{"location":"extra/methods/","page":"Exported methods","title":"Exported methods","text":"import ReactiveMP: mean as mean_from_reactivemp\nimport Distributions: mean as mean_from_distributions\nimport BayesBase: mean as mean_from_bayes_base","category":"page"},{"location":"extra/methods/","page":"Exported methods","title":"Exported methods","text":"mean_from_reactivemp === mean_from_distributions","category":"page"},{"location":"extra/methods/","page":"Exported methods","title":"Exported methods","text":"mean_from_reactivemp === mean_from_bayes_base","category":"page"},{"location":"extra/methods/","page":"Exported methods","title":"Exported methods","text":"Even though we import mean function from different packages they actually refer to the same object. Worth noting that this is not always the case - Julia will print a warning in case it finds unresolvable conflicts and usage of such functions will be disallowed unless user import them specifically. Read more about this in the section of the Julia's documentation.","category":"page"},{"location":"extra/methods/","page":"Exported methods","title":"Exported methods","text":"# It is easier to let Julia resolve names automatically\n# Julia will not overwrite `mean` that is coming from both packages\nusing ReactiveMP, Distributions, BayesBase, ExponentialFamily","category":"page"},{"location":"extra/methods/","page":"Exported methods","title":"Exported methods","text":"mean(Normal(0.0, 1.0)) # `Normal` is an object from `Distributions.jl`","category":"page"},{"location":"extra/methods/","page":"Exported methods","title":"Exported methods","text":"mean(NormalMeanVariance(0.0, 1.0)) # `NormalMeanVariance` is an object from `ReactiveMP.jl`","category":"page"},{"location":"extra/methods/#lib-list-methods","page":"Exported methods","title":"List of available methods","text":"","category":"section"},{"location":"extra/methods/","page":"Exported methods","title":"Exported methods","text":"Below you can find a list of exported methods from ReactiveMP.jl. All methods (even private) can be always accessed with ReactiveMP. prefix, e.g ReactiveMP.mean.","category":"page"},{"location":"extra/methods/","page":"Exported methods","title":"Exported methods","text":"note: Note\nSome exported names are (for legacy reasons) intended for private usage only. As a result some of these methods do not have a proper associated documentation with them. We constantly improve ReactiveMP.jl library and continue to add better documentation for many exported methods, but a small portion of these methods could be removed from this list in the future.","category":"page"},{"location":"extra/methods/","page":"Exported methods","title":"Exported methods","text":"using ReactiveMP #hide\nforeach(println, names(ReactiveMP))","category":"page"},{"location":"lib/rules/#lib-rules","page":"Message update rules","title":"Rules implementation","text":"","category":"section"},{"location":"lib/rules/#lib-message-rules","page":"Message update rules","title":"Message update rules","text":"","category":"section"},{"location":"lib/rules/","page":"Message update rules","title":"Message update rules","text":"rule\n@rule\n@call_rule\nReactiveMP.call_rule_make_node\nReactiveMP.call_rule_macro_parse_fn_args\nReactiveMP.call_rule_is_node_required\nReactiveMP.rule_macro_parse_on_tag\nReactiveMP.rule_macro_parse_fn_args\nReactiveMP.rule_macro_check_fn_args","category":"page"},{"location":"lib/rules/#ReactiveMP.rule","page":"Message update rules","title":"ReactiveMP.rule","text":"rule(fform, on, vconstraint, mnames, messages, qnames, marginals, meta, __node)\n\nThis function is used to compute an outbound message for a given node\n\nArguments\n\nfform: Functional form of the node in form of a type of the node, e.g. ::Type{ <: NormalMeanVariance } or ::typeof(+)\non: Outbound interface's tag for which a message has to be computed, e.g. ::Val{:out} or ::Val{:μ}\nvconstraint: Variable constraints for an outbound interface, e.g. Marginalisation or MomentMatching\nmnames: Ordered messages names in form of the Val type, eg. ::Val{ (:mean, :precision) }\nmessages: Tuple of message of the same length as mnames used to compute an outbound message\nqnames: Ordered marginal names in form of the Val type, eg. ::Val{ (:mean, :precision) }\nmarginals: Tuple of marginals of the same length as qnames used to compute an outbound message\nmeta: Extra meta information\naddons: Extra addons information\n__node: Node reference\n\nFor all available rules, see ReactiveMP.print_rules_table().\n\nSee also: @rule, marginalrule, @marginalrule\n\n\n\n\n\n","category":"function"},{"location":"lib/rules/#ReactiveMP.@rule","page":"Message update rules","title":"ReactiveMP.@rule","text":"@rule NodeType(:Edge, Constraint) (Arguments..., [ meta::MetaType ]) = begin\n    # rule body\n    return ...\nend\n\nThe @rule macro help to define new methods for the rule function. It works particularly well in combination with the @node macro. It has a specific structure, which must specify:\n\nNodeType: must be a valid Julia type. If some attempt to define a rule for a Julia function (for example +), use typeof(+)\nEdge: edge label, usually edge labels are defined with the @node macro\nConstrain: DEPRECATED, please just use the Marginalisation label\nArguments: defines a list of the input arguments for the rule\nm_* prefix indicates that the argument is of type Message from the edge *\nq_* prefix indicates that the argument is of type Marginal on the edge *\nMeta::MetaType - optionally, a user can specify a Meta object of type MetaType.  This can be useful is some attempts to try different rules with different approximation methods or if the rule itself requires some temporary storage or cache.  The default meta is nothing.\n\nHere are various examples of the @rule macro usage:\n\nBelief-Propagation (or Sum-Product) message update rule for the NormalMeanVariance node  toward the :μ edge with the Marginalisation constraint. Input arguments are m_out and m_v, which are the messages from the corresponding edges out and v and have the type PointMass.\n\n@rule NormalMeanVariance(:μ, Marginalisation) (m_out::PointMass, m_v::PointMass) = NormalMeanVariance(mean(m_out), mean(m_v))\n\nMean-field message update rule for the NormalMeanVariance node towards the :μ edge with the Marginalisation constraint. Input arguments are q_out and q_v, which are the marginals on the corresponding edges out and v of type Any.\n\n@rule NormalMeanVariance(:μ, Marginalisation) (q_out::Any, q_v::Any) = NormalMeanVariance(mean(q_out), mean(q_v))\n\nStructured Variational message update rule for the NormalMeanVariance node towards the :out edge with the Marginalisation constraint. Input arguments are m_μ, which is a message from the μ edge of type UnivariateNormalDistributionsFamily, and q_v, which is a marginal on the v edge of type Any.\n\n@rule NormalMeanVariance(:out, Marginalisation) (m_μ::UnivariateNormalDistributionsFamily, q_v::Any) = begin\n    m_μ_mean, m_μ_cov = mean_cov(m_μ)\n    return NormalMeanVariance(m_μ_mean, m_μ_cov + mean(q_v))\nend\n\nSee also: rule, marginalrule, [@marginalrule], @call_rule\n\n\n\n\n\n","category":"macro"},{"location":"lib/rules/#ReactiveMP.@call_rule","page":"Message update rules","title":"ReactiveMP.@call_rule","text":"@call_rule NodeType(:edge, Constraint) (argument1 = value1, argument2 = value2, ..., [ meta = ..., addons = ... ])\n\nThe @call_rule macro helps to call the rule method with an easier syntax.  The structure of the macro is almost the same as in the @rule macro, but there is no begin ... end block, but instead each argument must have a specified value with the = operator.\n\nThe @call_rule accepts optional list of options before the functional form specification, for example:\n\n@call_rule [ return_addons = true ] NodeType(:edge, Constraint) (argument1 = value1, argument2 = value2, ..., [ meta = ..., addons = ... ])\n\nThe list of available options is:\n\nreturn_addons - forces the @call_rule to return the tuple of (result, addons)\nfallback - specifies the fallback rule to use in case the rule is not defined for the given NodeType and specified arguments\n\nSee also: @rule, rule, @call_marginalrule\n\n\n\n\n\n","category":"macro"},{"location":"lib/rules/#ReactiveMP.call_rule_make_node","page":"Message update rules","title":"ReactiveMP.call_rule_make_node","text":"call_rule_create_node(::Type{ NodeType }, fformtype)\n\nCreates a node object that will be used inside @call_rule macro. \n\n\n\n\n\n","category":"function"},{"location":"lib/rules/#ReactiveMP.call_rule_macro_parse_fn_args","page":"Message update rules","title":"ReactiveMP.call_rule_macro_parse_fn_args","text":"call_rule_macro_parse_fn_args(inputs; specname, prefix, proxy)\n\nDo not use this function directly. This function is private and does not belong to the public API.\n\nThis function is used to parse an arguments tuple for message and marginal calling rules specification. \n\n@call_rule MvNormalMeanPrecision(:out, Marginalisation) (m_μ = NormalMeanPrecision(...), m_τ = PointMass(...)) = begin \n                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                                                        `arguments` vector\n    ...\nend\n\nAccepts a vector of (name, value) elements, specname, name prefix and proxy type.  Returns parsed names without prefix and proxied values\n\nSee also: @rule\n\n\n\n\n\n","category":"function"},{"location":"lib/rules/#ReactiveMP.call_rule_is_node_required","page":"Message update rules","title":"ReactiveMP.call_rule_is_node_required","text":"call_rule_is_node_required(fformtype)\n\nReturns either CallRuleNodeRequired() or CallRuleNodeNotRequired() depending on if a specific  fformtype requires an access to the corresponding node in order to compute a message update rule. Returns CallRuleNodeNotRequired() for all known functional forms by default and CallRuleNodeRequired() for all unknown functional forms.\n\n\n\n\n\n","category":"function"},{"location":"lib/rules/#ReactiveMP.rule_macro_parse_on_tag","page":"Message update rules","title":"ReactiveMP.rule_macro_parse_on_tag","text":"rule_macro_parse_on_tag(expression)\n\nDo not use this function directly. This function is private and does not belong to the public API.\n\nThis function is used to parse an on tag for message rules and marginal rules specification. \n\n@rule MvNormalMeanPrecision(:out, Marginalisation) (...) = begin \n                            ^^^^\n                            `on` tag\n    ...\nend\n\nor \n\n@rule NormalMixture((:m, k), Marginalisation) (...) = begin \n                    ^^^^^^^\n                    `on` tag\n    ...\nend\n\nAccepts either a quoted symbol expressions or a (name, index) tuple expression. Returns name expression, index expression and index initialisation expression.\n\nSee also: @rule\n\n\n\n\n\n","category":"function"},{"location":"lib/rules/#ReactiveMP.rule_macro_parse_fn_args","page":"Message update rules","title":"ReactiveMP.rule_macro_parse_fn_args","text":"rule_macro_parse_fn_args(inputs; specname, prefix, proxy)\n\nDo not use this function directly. This function is private and does not belong to the public API.\n\nThis function is used to parse an arguments tuple for message rules and marginal rules specification. \n\n@rule MvNormalMeanPrecision(:out, Marginalisation) (m_μ::NormalMeanPrecision, m_τ::PointMass) = begin \n                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                                                   `arguments` vector\n    ...\nend\n\nAccepts a vector of (name, type) elements, specname, name prefix and proxy type.  Returns parsed names without prefix, proxied types and initialisation code block.\n\nSee also: @rule\n\n\n\n\n\n","category":"function"},{"location":"lib/rules/#ReactiveMP.rule_macro_check_fn_args","page":"Message update rules","title":"ReactiveMP.rule_macro_check_fn_args","text":"rule_macro_check_fn_args(inputs; allowed_inputs, allowed_prefixes)\n\nThis function checks if all inputs are either in the allowed_inputs or have prefixes in the allowed_prefixes.\n\nSee also: @rule\n\n\n\n\n\n","category":"function"},{"location":"lib/rules/#lib-marginal-rules","page":"Message update rules","title":"Marginal update rules","text":"","category":"section"},{"location":"lib/rules/","page":"Message update rules","title":"Message update rules","text":"marginalrule\n@marginalrule\n@call_marginalrule","category":"page"},{"location":"lib/rules/#ReactiveMP.marginalrule","page":"Message update rules","title":"ReactiveMP.marginalrule","text":"marginalrule(fform, on, mnames, messages, qnames, marginals, meta, __node)\n\nThis function is used to compute a local joint marginal for a given node\n\nArguments\n\nfform: Functional form of the node in form of a type of the node, e.g. ::Type{ <: NormalMeanVariance } or ::typeof(+)\non: Local joint marginal tag , e.g. ::Val{ :mean_precision } or ::Val{ :out_mean_precision }\nmnames: Ordered messages names in form of the Val type, eg. ::Val{ (:mean, :precision) }\nmessages: Tuple of message of the same length as mnames used to compute an outbound message\nqnames: Ordered marginal names in form of the Val type, eg. ::Val{ (:mean, :precision) }\nmarginals: Tuple of marginals of the same length as qnames used to compute an outbound message\nmeta: Extra meta information\n__node: Node reference\n\nSee also: rule, @rule @marginalrule\n\n\n\n\n\n","category":"function"},{"location":"lib/rules/#ReactiveMP.@marginalrule","page":"Message update rules","title":"ReactiveMP.@marginalrule","text":"@marginalrule NodeType(:Cluster) (Arguments..., [ meta::MetaType ]) = begin\n    # rule body\n    return ...\nend\n\nThe @marginalrule macro help to define new methods for the marginalrule function. It works particularly well in combination with the @node macro. It has a specific structure, which must specify:\n\nNodeType: must be a valid Julia type. If some attempt to define a rule for a Julia function (for example +), use typeof(+)\nCluster: edge cluster that contains joined edge labels with the _ symbol. Usually edge labels are defined with the @node macro\nArguments: defines a list of the input arguments for the rule\nm_* prefix indicates that the argument is of type Message from the edge *\nq_* prefix indicates that the argument is of type Marginal on the edge *\nMeta::MetaType - optionally, a user can specify a Meta object of type MetaType.  This can be useful is some attempts to try different rules with different approximation methods or if the rule itself requires some temporary storage or cache.  The default meta is nothing.\n\nThe @marginalrule can return a NamedTuple in the return statement. This would indicate some variables in the joint marginal  for the Cluster are independent and the joint itself is factorised. For example if some attempts to compute a marginal for the q(x, y) it is possible to return (x = ..., y = ...) as the result of the computation to indicate that q(x, y) = q(x)q(y).\n\nHere are various examples of the @marginalrule macro usage:\n\nMarginal computation rule around the NormalMeanPrecision node for the q(out, μ). The rule accepts arguments m_out and m_μ, which are the messages \n\nfrom the out and μ edges respectively, and q_τ which is the marginal on the edge τ.\n\n@marginalrule NormalMeanPrecision(:out_μ) (m_out::UnivariateNormalDistributionsFamily, m_μ::UnivariateNormalDistributionsFamily, q_τ::Any) = begin\n    xi_out, W_out = weightedmean_precision(m_out)\n    xi_μ, W_μ     = weightedmean_precision(m_μ)\n\n    W_bar = mean(q_τ)\n\n    W  = [W_out+W_bar -W_bar; -W_bar W_μ+W_bar]\n    xi = [xi_out; xi_μ]\n\n    return MvNormalWeightedMeanPrecision(xi, W)\nend\n\nMarginal computation rule around the NormalMeanPrecision node for the q(out, μ). The rule accepts arguments m_out and m_μ, which are the messages from the \n\nout and μ edges respectively, and q_τ which is the marginal on the edge τ. In this example the result of the computation is a NamedTuple\n\n@marginalrule NormalMeanPrecision(:out_μ) (m_out::PointMass, m_μ::UnivariateNormalDistributionsFamily, q_τ::Any) = begin\n    return (out = m_out, μ = prod(ClosedProd(), NormalMeanPrecision(mean(m_out), mean(q_τ)), m_μ))\nend\n\n\n\n\n\n","category":"macro"},{"location":"lib/rules/#ReactiveMP.@call_marginalrule","page":"Message update rules","title":"ReactiveMP.@call_marginalrule","text":"@call_marginalrule NodeType(:edge) (argument1 = value1, argument2 = value2, ..., [ meta = ... ])\n\nThe @call_marginalrule macro helps to call the marginalrule method with an easier syntax.  The structure of the macro is almost the same as in the @marginalrule macro, but there is no begin ... end block,  but instead each argument must have a specified value with the = operator.\n\nSee also: @marginalrule, marginalrule, @call_rule\n\n\n\n\n\n","category":"macro"},{"location":"lib/rules/#lib-rules-tests","page":"Message update rules","title":"Testing utilities for the update rules","text":"","category":"section"},{"location":"lib/rules/","page":"Message update rules","title":"Message update rules","text":"ReactiveMP.@test_rules\nReactiveMP.@test_marginalrules","category":"page"},{"location":"lib/rules/#ReactiveMP.@test_rules","page":"Message update rules","title":"ReactiveMP.@test_rules","text":"@test_rules [options] rule [ test_entries... ]\n\nThe @test_rules macro generates test cases for message update rules for probabilistic programming models that follow the \"message passing\" paradigm. It takes a rule specification as input and generates a set of tests based on that specification. This macro is provided by ReactiveMP.\n\nNote: The Test module must be imported explicitly. The @test_rules macro tries to use the @test macro, which must be defined globally.\n\nArguments\n\nThe macro takes three arguments:\n\noptions: An optional argument that specifies the options for the test generation process. See below for details.\nrule: A rule specification in the same format as the @rule macro, e.g. Beta(:out, Marginalisation) or NormalMeanVariance(:μ, Marginalisation).\ntest_entries: An array of named tuples (input = ..., output = ...). The input entry has the same format as the input for the @rule macro. The output entry specifies the expected output.\n\nOptions\n\nThe following options are available:\n\ncheck_type_promotion: By default, this option is set to false. If set to true, the macro generates an extensive list of extra tests that aim to check the correct type promotion within the tests. For example, if all inputs are of type Float32, then the expected output should also be of type Float32. See the paramfloattype and convert_paramfloattype functions for details.\natol: Sets the desired accuracy for the tests. The tests use the custom_rule_isapprox function from ReactiveMP to check if outputs are approximately the same. This argument can be either a single number or an array of key => value pairs.\nextra_float_types: A set of extra float types to be used in the check_type_promotion tests. This argument has no effect if check_type_promotion is set to false.\n\nThe default values for the atol option are:\n\nFloat32: 1e-4\nFloat64: 1e-6\nBigFloat: 1e-8\n\nExamples\n\n\n@test_rules [check_type_promotion = true] Beta(:out, Marginalisation) [\n    (input = (m_a = PointMass(1.0), m_b = PointMass(2.0)), output = Beta(1.0, 2.0)),\n    (input = (m_a = PointMass(2.0), m_b = PointMass(2.0)), output = Beta(2.0, 2.0)),\n    (input = (m_a = PointMass(3.0), m_b = PointMass(3.0)), output = Beta(3.0, 3.0))\n]\n\n@test_rules [check_type_promotion = true] Beta(:out, Marginalisation) [\n    (input = (q_a = PointMass(1.0), q_b = PointMass(2.0)), output = Beta(1.0, 2.0)),\n    (input = (q_a = PointMass(2.0), q_b = PointMass(2.0)), output = Beta(2.0, 2.0)),\n    (input = (q_a = PointMass(3.0), q_b = PointMass(3.0)), output = Beta(3.0, 3.0))\n]\n\nSee also: ReactiveMP.@test_marginalrules\n\n\n\n\n\n","category":"macro"},{"location":"lib/rules/#ReactiveMP.@test_marginalrules","page":"Message update rules","title":"ReactiveMP.@test_marginalrules","text":"@test_marginalrules [options] rule [ test_entries... ]\n\nEffectively the same as @test_rules, but for marginal computation rules. See the documentation for @test_rules for more info.\n\nSee also: ReactiveMP.@test_rules\n\n\n\n\n\n","category":"macro"},{"location":"lib/rules/#lib-rules-fallbacks","page":"Message update rules","title":"Rule fallbacks","text":"","category":"section"},{"location":"lib/rules/","page":"Message update rules","title":"Message update rules","text":"ReactiveMP.NodeFunctionRuleFallback\nReactiveMP.nodefunction","category":"page"},{"location":"lib/rules/#ReactiveMP.NodeFunctionRuleFallback","page":"Message update rules","title":"ReactiveMP.NodeFunctionRuleFallback","text":"NodeFunctionRuleFallback(extractfn = mean)\n\nA fallback rule for Stochastic nodes that uses a specified function (default: mean) to transform messages and marginals into a value.  It calls the nodefunction method to create the message.\n\nWhen a node is defined with the @node macro:\n\n1.\tThe nodefunction typically calls logpdf associated with the node's distribution. 2.\tThe first edge in the @node specification is used to evaluate logpdf at. 3.\tOther edges are used to instantiate the associated distribution object.\n\njulia> using ReactiveMP, BayesBase, Distributions\n\njulia> struct MyBeta{A, B} <: ContinuousUnivariateDistribution\n             a::A\n             b::B\n       end\n\njulia> BayesBase.logpdf(d::MyBeta, x) = logpdf(Beta(d.a, d.b), x)\n\njulia> BayesBase.insupport(d::MyBeta, x::Real) = true\n\njulia> @node MyBeta Stochastic [out, a, b]\n\njulia> message = @call_rule [fallback = NodeFunctionRuleFallback()] MyBeta(:out, Marginalisation) (m_a = Beta(2, 3), m_b = Beta(3, 2));\n\njulia> logpdf(message, 0.5)\n-0.5017644952110732\n\njulia> message = @call_rule [fallback = NodeFunctionRuleFallback(mode)] MyBeta(:out, Marginalisation) (m_a = Beta(2, 3), m_b = Beta(3, 2)); # evaluate at `mode`\n\njulia> logpdf(message, 0.5)\n-0.5954237415153454\n\n\n\n\n\n","category":"type"},{"location":"lib/rules/#ReactiveMP.nodefunction","page":"Message update rules","title":"ReactiveMP.nodefunction","text":"nodefunction(::Type{T}) where {T}\n\nReturns a function that represents a node of type T.  The function typically takes arguments that represent the node's input and output variables in the same order as defined in the @node macro.\n\n\n\n\n\n","category":"function"},{"location":"lib/rules/#lib-rules-table","page":"Message update rules","title":"Table of available update rules","text":"","category":"section"},{"location":"lib/rules/","page":"Message update rules","title":"Message update rules","text":"note: Note\nThe list below has been automatically generated with the ReactiveMP.print_rules_table() function.","category":"page"},{"location":"lib/rules/","page":"Message update rules","title":"Message update rules","text":"using ReactiveMP, Markdown\nMarkdown.parse(ReactiveMP.print_rules_table())","category":"page"},{"location":"lib/nodes/bifm/#lib-nodes-bifm","page":"BIFM","title":"BIFM node","text":"","category":"section"},{"location":"lib/nodes/bifm/","page":"BIFM","title":"BIFM","text":"See also BIFM tutorial for a comprehensive guide on using BIFM node in RxInfer.jl.","category":"page"},{"location":"lib/nodes/bifm/","page":"BIFM","title":"BIFM","text":"ReactiveMP.BIFM\nReactiveMP.BIFMMeta\nReactiveMP.BIFMHelper","category":"page"},{"location":"lib/nodes/bifm/#ReactiveMP.BIFM","page":"BIFM","title":"ReactiveMP.BIFM","text":"The BIFM node is a node that can be used as a substitution for a state space model. It includes all factor of the time slice to perform efficient inference. This node needs to be used in conjuction with the BIFMHelper node for efficient inference.\n\nout ~ BIFM(in, zprev, znext)\n\nInterfaces:\n\nout - latent output (observation) of the BIFM node\nin - latent input of the BIFM node\nzprev - previous latent state of the BIFM node\nznext - next latent state of the BIFM node\n\nNote: When performing inference, first subscribe to the marginals (in the order: z, out, in) and then to the free energy score function.\n\nExample\n\n# set priors\nz_prior ~ MvNormalMeanPrecision(zeros(latent_dim), diagm(ones(latent_dim)))\nz_tmp   ~ BIFMHelper(z_prior)\n\n# update last/previous hidden state\nz_prev = z_tmp\n\n# loop through observations\nfor i in 1:nr_samples\n\n    # specify input as random variable\n    u[i]   ~ MvNormalMeanPrecision(μu, Wu)\n\n    # specify observation\n    xt[i]  ~ BIFM(u[i], z_prev, z[i]) where { meta = BIFMMeta(A, B, C) }\n    x[i]   ~ MvNormalMeanPrecision(xt[i], Wx)\n    \n    # update last/previous hidden state\n    z_prev = z[i]\n\nend\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/bifm/#ReactiveMP.BIFMMeta","page":"BIFM","title":"ReactiveMP.BIFMMeta","text":"The BIFMMeta structure contains all characterizing information of the BIFM node. In addition, it stores intermediate variables for efficient computations.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/bifm/#ReactiveMP.BIFMHelper","page":"BIFM","title":"ReactiveMP.BIFMHelper","text":"The BIFMHelper node is a node required to perform efficient message passing inconjuction with the BIFM node. It is required to switch from the backward pass with messages to the forward pass with marginals.\n\nout ~ BIFMHelper(in)\n\nInterfaces:\n\nout - output of the BIFMHelper node, should be connected to the state space model.\nin - input of the BIFMHelper node, should be connected to the prior for the latent state.\n\nNote: When performing inference, first subscribe to the marginals (in the order: z, out, in) and then to the free energy score function.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/equality/#lib-nodes-equality","page":"Equality node","title":"Equality node","text":"","category":"section"},{"location":"lib/nodes/equality/","page":"Equality node","title":"Equality node","text":"ReactiveMP.EqualityNode\nReactiveMP.EqualityChain","category":"page"},{"location":"lib/nodes/equality/#ReactiveMP.EqualityNode","page":"Equality node","title":"ReactiveMP.EqualityNode","text":"EqualityNode\n\nGeneric idea of an equality node is to keep track of intermediate left and right messages  in a convenient manner so they can be reused during prod for random variables with large degree.\n\n<- left    –––-     right ->      ––- |   =   | –––             –––-                |                | outbound\n\nAttributes:\n\nleft: An observable that indicates that left message can be computed, always sends missing since we are not interested in actual value. Can be treated as notification.\nright: An observable that indicates that right message can be computed, always sends missing since we are not interested in actual value. Can be treated as notification.\ncache_left: Keeps cached value for left outbound message, node itself does not track if cache is valid or not. Cache integrity is tracked by EqualityChain.\ncache_right: Keeps cached value for right outbound message, node itself does not track if cache is valid or not. Cache integrity is tracked by EqualityChain.\n\nSee also: EqualityChain\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/equality/#ReactiveMP.EqualityChain","page":"Equality node","title":"ReactiveMP.EqualityChain","text":"EqualityChain\n\n\n\n\n\n","category":"type"},{"location":"#ReactiveMP.jl","page":"Introduction","title":"ReactiveMP.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Julia package for reactive message passing Bayesian inference engine on a factor graph.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nThis package exports only an inference engine, for the full ecosystem with convenient model and constraints specification we refer user to the RxInfer.jl package and its documentation.","category":"page"},{"location":"#Ideas-and-principles-behind-ReactiveMP.jl","page":"Introduction","title":"Ideas and principles behind ReactiveMP.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"ReactiveMP.jl is a particular implementation of message passing on factor graphs, which does not create any specific message passing schedule in advance, but rather reacts on changes in the data source (hence reactive in the name of the package). The detailed explanation of the ideas and principles behind the Reactive Message Passing can be found in PhD disseration of Dmitry Bagaev titled Reactive Probabilistic Programming for Scalable Bayesian Inference (link2, link3).","category":"page"},{"location":"#Examples-and-tutorials","page":"Introduction","title":"Examples and tutorials","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The ReactiveMP.jl package is intended for advanced users with a deep understanding of message passing principles.  Accesible tutorials and examples are available in the RxInfer documentation.","category":"page"},{"location":"#Table-of-Contents","page":"Introduction","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\n  \"lib/nodes.md\",\n  \"lib/message.md\",\n  \"lib/marginal.md\",\n  \"lib/rules.md\",\n  \"lib/nodes.md\",\n  \"lib/helpers.md\",\n  \"lib/algebra.md\",\n  \"extra/contributing.md\",\n  \"extra/extensions.md\",\n  \"extra/methods.md\",\n]\nDepth = 2","category":"page"},{"location":"#Index","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"lib/helpers/#lib-helpers","page":"Helper utils","title":"Helper utilities","text":"","category":"section"},{"location":"lib/helpers/","page":"Helper utils","title":"Helper utils","text":"ReactiveMP implements various structures/functions/methods as \"helper\" structures that might be useful in various contexts.","category":"page"},{"location":"lib/helpers/","page":"Helper utils","title":"Helper utils","text":"ReactiveMP.SkipIndexIterator\nReactiveMP.skipindex\nReactiveMP.MacroHelpers.proxy_type\nReactiveMP.MacroHelpers.ensure_symbol\nReactiveMP.MacroHelpers.@proxy_methods\nReactiveMP.MacroHelpers.upper_type\nReactiveMP.MacroHelpers.bottom_type","category":"page"},{"location":"lib/helpers/#ReactiveMP.SkipIndexIterator","page":"Helper utils","title":"ReactiveMP.SkipIndexIterator","text":"SkipIndexIterator\n\nA special type of iterator that simply iterates over internal iterator, but skips index skip.\n\nArguments\n\niterator: internal iterator\nskip: index to skip (integer)\n\nSee also: skipindex\n\n\n\n\n\n","category":"type"},{"location":"lib/helpers/#ReactiveMP.skipindex","page":"Helper utils","title":"ReactiveMP.skipindex","text":"skipindex(iterator, skip)\n\nCreation operator for SkipIndexIterator.\n\njulia> s = ReactiveMP.skipindex(1:3, 2)\n2-element ReactiveMP.SkipIndexIterator{Int64, UnitRange{Int64}}:\n 1\n 3\n\njulia> collect(s)\n2-element Vector{Int64}:\n 1\n 3\n\nSee also: SkipIndexIterator\n\n\n\n\n\n","category":"function"},{"location":"lib/helpers/#ReactiveMP.MacroHelpers.proxy_type","page":"Helper utils","title":"ReactiveMP.MacroHelpers.proxy_type","text":"proxy_type(proxy, type)\n\nReturns a type wrapped with a proxy type in a form of ProxyType{ <: Type }.\n\nArguments\n\nproxy: Proxy type used to wrap type\ntype: Type to be wrapped\n\n\n\n\n\n","category":"function"},{"location":"lib/helpers/#ReactiveMP.MacroHelpers.ensure_symbol","page":"Helper utils","title":"ReactiveMP.MacroHelpers.ensure_symbol","text":"ensure_symbol(input)\n\nThis function ensures that the given argument has a Symbol type\n\n\n\n\n\n","category":"function"},{"location":"lib/helpers/#ReactiveMP.MacroHelpers.@proxy_methods","page":"Helper utils","title":"ReactiveMP.MacroHelpers.@proxy_methods","text":"@proxy_methods(proxy_type, proxy_getter, proxy_methods)\n\nGenerates proxy methods for a specified proxy_type using proxy_getter. For example:\n\n@proxy_methods Message getdata [ \n    Distributions.mean, \n    Distributions.var \n]\n\ngenerates:\n\nDistributions.mean(proxy::Message) = Distributions.mean(getdata(proxy))\nDistributions.var(proxy::Message)  = Distributions.mean(getdata(proxy))\n\n\n\n\n\n","category":"macro"},{"location":"lib/helpers/#ReactiveMP.MacroHelpers.upper_type","page":"Helper utils","title":"ReactiveMP.MacroHelpers.upper_type","text":"upper_type(type)\n\nThis function returns Type{ <: T } expression for the following input expressions:\n\ntypeof(T)\nType{ <: T }\nType{ T }\nT\n\nArguments\n\ntype: Type expression to be extended\n\n\n\n\n\n","category":"function"},{"location":"lib/helpers/#ReactiveMP.MacroHelpers.bottom_type","page":"Helper utils","title":"ReactiveMP.MacroHelpers.bottom_type","text":"bottom_type(type)\n\nThis function returns T expression for the following input expressions:\n\ntypeof(T)\nType{ <: T }\nType{ T }\nT\n\nArguments\n\ntype: Type expression to be lowered\n\n\n\n\n\n","category":"function"}]
}
