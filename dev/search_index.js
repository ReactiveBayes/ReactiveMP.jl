var documenterSearchIndex = {"docs":
[{"location":"lib/helpers/#lib-helpers","page":"Helper utils","title":"Helper utilities","text":"","category":"section"},{"location":"lib/helpers/","page":"Helper utils","title":"Helper utils","text":"ReactiveMP implements various structures/functions/methods as \"helper\" structures that might be useful in various contexts.","category":"page"},{"location":"lib/helpers/#lib-helpers-skip-index-iterator","page":"Helper utils","title":"SkipIndexIterator","text":"","category":"section"},{"location":"lib/helpers/","page":"Helper utils","title":"Helper utils","text":"ReactiveMP.SkipIndexIterator\nReactiveMP.skipindex","category":"page"},{"location":"lib/helpers/#ReactiveMP.SkipIndexIterator","page":"Helper utils","title":"ReactiveMP.SkipIndexIterator","text":"SkipIndexIterator\n\nA special type of iterator that simply iterates over internal iterator, but skips index skip.\n\nArguments\n\niterator: internal iterator\nskip: index to skip (integer)\n\nSee also: skipindex\n\n\n\n\n\n","category":"type"},{"location":"lib/helpers/#ReactiveMP.skipindex","page":"Helper utils","title":"ReactiveMP.skipindex","text":"skipindex(iterator, skip)\n\nCreation operator for SkipIndexIterator.\n\njulia> s = ReactiveMP.skipindex(1:3, 2)\n2-element ReactiveMP.SkipIndexIterator{Int64, UnitRange{Int64}}:\n 1\n 3\n\njulia> collect(s)\n2-element Vector{Int64}:\n 1\n 3\n\nSee also: SkipIndexIterator\n\n\n\n\n\n","category":"function"},{"location":"lib/helpers/#lib-helpers-deep-eltype","page":"Helper utils","title":"deep_eltype","text":"","category":"section"},{"location":"lib/helpers/","page":"Helper utils","title":"Helper utils","text":"ReactiveMP.deep_eltype","category":"page"},{"location":"lib/helpers/#ReactiveMP.deep_eltype","page":"Helper utils","title":"ReactiveMP.deep_eltype","text":"deep_eltype\n\nReturns the eltype of the first container in the nested hierarchy.\n\njulia> ReactiveMP.deep_eltype([ [1, 2], [2, 3] ])\nInt64\n\njulia> ReactiveMP.deep_eltype([[[ 1.0, 2.0 ], [ 3.0, 4.0 ]], [[ 5.0, 6.0 ], [ 7.0, 8.0 ]]])\nFloat64\n\n\n\n\n\n","category":"function"},{"location":"lib/helpers/#lib-helpers-functional-index","page":"Helper utils","title":"FunctionalIndex","text":"","category":"section"},{"location":"lib/helpers/","page":"Helper utils","title":"Helper utils","text":"ReactiveMP.FunctionalIndex","category":"page"},{"location":"lib/helpers/#ReactiveMP.FunctionalIndex","page":"Helper utils","title":"ReactiveMP.FunctionalIndex","text":"FunctionalIndex\n\nA special type of an index that represents a function that can be used only in pair with a collection.  An example of a FunctionalIndex can be firstindex or lastindex, but more complex use cases are possible too,  e.g. firstindex + 1. Important part of the implementation is that the resulting structure is isbitstype(...) = true, that allows to store it in parametric type as valtype.\n\nOne use case for this structure is to dispatch on and to replace begin or end (or more complex use cases, e.g. begin + 1) markers in constraints specification language.\n\n\n\n\n\n","category":"type"},{"location":"lib/message/#lib-message","page":"Messages","title":"Messages implementation","text":"","category":"section"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"In message passing framework one of the most important concepts is (wow!) messages. Messages flow on edges of a factor graph and usually hold some information in a form of probability distribution. In ReactiveMP.jl we distinguish two major types of messages: Belief Propagation and Variational.  ","category":"page"},{"location":"lib/message/#Abstract-message-type","page":"Messages","title":"Abstract message type","text":"","category":"section"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"Both belief propagation and variational messages are subtypes of a AbstractMessage supertype.","category":"page"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"AbstractMessage","category":"page"},{"location":"lib/message/#ReactiveMP.AbstractMessage","page":"Messages","title":"ReactiveMP.AbstractMessage","text":"AbstractMessage\n\nAn abstract supertype for all concrete message types.\n\nSee also: Message\n\n\n\n\n\n","category":"type"},{"location":"lib/message/#lib-belief-propagation-message","page":"Messages","title":"Belief-Propagation (or Sum-Product) message","text":"","category":"section"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"Belief propagation messages are encoded with type Message. ","category":"page"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"(Image: message) Belief propagation message","category":"page"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"Message","category":"page"},{"location":"lib/message/#ReactiveMP.Message","page":"Messages","title":"ReactiveMP.Message","text":"Message{D, A} <: AbstractMessage\n\nMessage structure encodes a Belief Propagation message, which holds some data that usually a probability distribution, but can also be an arbitrary object. Message acts as a proxy structure to data object and proxies most of the statistical functions, e.g. mean, mode, cov etc.\n\nArguments\n\ndata::D: message always holds some data object associated with it\nis_clamped::Bool, specifies if this message is clamped\nis_initial::Bool, specifies if this message is initial\naddons::A, specifies the addons of the message\n\nExample\n\njulia> distribution = Gamma(10.0, 2.0)\nGamma{Float64}(α=10.0, θ=2.0)\n\njulia> message = Message(distribution, false, true, nothing)\nMessage(Gamma{Float64}(α=10.0, θ=2.0))\n\njulia> mean(message) \n20.0\n\njulia> getdata(message)\nGamma{Float64}(α=10.0, θ=2.0)\n\njulia> is_clamped(message)\nfalse\n\njulia> is_initial(message)\ntrue\n\n\nSee also: AbstractMessage, materialize!\n\n\n\n\n\n","category":"type"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"From implementation point a view Message structure does nothing but holds some data object and redirects most of the statistical related functions to that data object. However it used extensively in Julia's multiple dispatch. Implementation also uses extra is_initial and is_clamped fields to determine if product of two messages results in is_initial or is_clamped posterior marginal.","category":"page"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"using ReactiveMP","category":"page"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"distribution = NormalMeanPrecision(0.0, 1.0)\nmessage      = Message(distribution, false, true, nothing)","category":"page"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"mean(message), precision(message)","category":"page"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"logpdf(message, 1.0)","category":"page"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"is_clamped(message), is_initial(message)","category":"page"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"The user should not really interact with Message structure while working with ReactiveMP unless doing some advanced inference procedures that involve prediction.","category":"page"},{"location":"lib/message/#lib-variational-message","page":"Messages","title":"Variational message","text":"","category":"section"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"Variational messages are encoded with type VariationalMessage.","category":"page"},{"location":"lib/message/","page":"Messages","title":"Messages","text":"(Image: message) Variational message with structured factorisation q(x, y)q(z) assumption","category":"page"},{"location":"lib/nodes/nodes/#lib-node","page":"Overview","title":"Nodes implementation","text":"","category":"section"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"In the message passing framework, one of the most important concepts is a factor node. A factor node represents a local function in a factorised representation of a generative model.","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"note: Note\nTo quickly check the list of all available factor nodes that can be used in the model specification language, call ?make_node or Base.doc(make_node).","category":"page"},{"location":"lib/nodes/nodes/#lib-custom-node","page":"Overview","title":"Adding a custom node","text":"","category":"section"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"ReactiveMP.jl exports the @node macro that allows for quick definition of a factor node with a fixed number of edges. The interface is the following:","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"struct MyNewCustomNode end\n\n@node MyNewCustomNode   Stochastic         [ x, y, z ]\n#     ^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^      ^^^^^^^^^^^\n#     Node's tag/name   Node's type        A fixed set of edges\n#                       Another possible   The very first edge (in this example `x`) is considered\n#                       value is           to be the output of the node\n#                       `Deterministic`","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"This expression registers a new node that can be used with the inference engine. Note howeve, that the @node macro does not generate any message passing update rules. These must be defined using the @rule macro.","category":"page"},{"location":"lib/nodes/nodes/#lib-node-types","page":"Overview","title":"Node types","text":"","category":"section"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"We distinguish different types of factor nodes in order to have better control over Bethe Free Energy computation. Each factor node has either the Deterministic or Stochastic functional form type.","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"Deterministic\nStochastic\nisdeterministic\nisstochastic\nsdtype","category":"page"},{"location":"lib/nodes/nodes/#ReactiveMP.Deterministic","page":"Overview","title":"ReactiveMP.Deterministic","text":"Deterministic\n\nDeterministic object used to parametrize factor node object with determinstic type of relationship between variables.\n\nSee also: Stochastic, isdeterministic, isstochastic, sdtype\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/nodes/#ReactiveMP.Stochastic","page":"Overview","title":"ReactiveMP.Stochastic","text":"Stochastic\n\nStochastic object used to parametrize factor node object with stochastic type of relationship between variables.\n\nSee also: Deterministic, isdeterministic, isstochastic, sdtype\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/nodes/#ReactiveMP.isdeterministic","page":"Overview","title":"ReactiveMP.isdeterministic","text":"isdeterministic(node)\n\nFunction used to check if factor node object is deterministic or not. Returns true or false.\n\nSee also: Deterministic, Stochastic, isstochastic, sdtype\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/nodes/#ReactiveMP.isstochastic","page":"Overview","title":"ReactiveMP.isstochastic","text":"isstochastic(node)\n\nFunction used to check if factor node object is stochastic or not. Returns true or false.\n\nSee also: Deterministic, Stochastic, isdeterministic, sdtype\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/nodes/#ReactiveMP.sdtype","page":"Overview","title":"ReactiveMP.sdtype","text":"sdtype(object)\n\nReturns either Deterministic or Stochastic for a given object (if defined).\n\nSee also: Deterministic, Stochastic, isdeterministic, isstochastic\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"using ReactiveMP","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"For example the + node has the Deterministic type:","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"plus_node = make_node(+)\n\nprintln(\"Is `+` node deterministic: \", isdeterministic(plus_node))\nprintln(\"Is `+` node stochastic: \", isstochastic(plus_node))\nnothing #hide","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"On the other hand, the Bernoulli node has the Stochastic type:","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"bernoulli_node = make_node(Bernoulli)\n\nprintln(\"Is `Bernoulli` node deterministic: \", isdeterministic(bernoulli_node))\nprintln(\"Is `Bernoulli` node stochastic: \", isstochastic(bernoulli_node))","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"To get an actual instance of the type object we use sdtype function:","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"println(\"sdtype() of `+` node is \", sdtype(plus_node))\nprintln(\"sdtype() of `Bernoulli` node is \", sdtype(bernoulli_node))\nnothing #hide","category":"page"},{"location":"lib/nodes/nodes/#lib-node-functional-dependencies-pipeline","page":"Overview","title":"Node functional dependencies pipeline","text":"","category":"section"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"The generic implementation of factor nodes in ReactiveMP supports custom functional dependency pipelines. Briefly, the functional dependencies pipeline defines what dependencies are need to compute a single message. As an example, consider the belief-propagation message update equation for a factor node f with three edges: x, y and z:","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"mu(x) = int mu(y) mu(z) f(x y z) mathrmdy mathrmdz","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"Here we see that in the standard setting for the belief-propagation message out of edge x, we need only messages from the edges y and z. In contrast, consider the variational message update rule equation with mean-field assumption:","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"mu(x) = exp int q(y) q(z) log f(x y z) mathrmdy mathrmdz","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"We see that in this setting, we do not need messages mu(y) and mu(z), but only the marginals q(y) and q(z). The purpose of a functional dependencies pipeline is to determine functional dependencies (a set of messages or marginals) that are needed to compute a single message. By default, ReactiveMP.jl uses so-called DefaultFunctionalDependencies that correctly implements belief-propagation and variational message passing schemes (including both mean-field and structured factorisations). The full list of built-in pipelines is presented below:","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"ReactiveMP.DefaultFunctionalDependencies\nReactiveMP.RequireMessageFunctionalDependencies\nReactiveMP.RequireMarginalFunctionalDependencies\nReactiveMP.RequireEverythingFunctionalDependencies","category":"page"},{"location":"lib/nodes/nodes/#ReactiveMP.DefaultFunctionalDependencies","page":"Overview","title":"ReactiveMP.DefaultFunctionalDependencies","text":"DefaultFunctionalDependencies\n\nThis pipeline translates directly to enforcing a variational message passing scheme. In order to compute a message out of some edge, this pipeline requires messages from edges within the same edge-cluster and marginals over other edge-clusters.\n\nSee also: ReactiveMP.RequireMessageFunctionalDependencies, ReactiveMP.RequireMarginalFunctionalDependencies, ReactiveMP.RequireEverythingFunctionalDependencies\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/nodes/#ReactiveMP.RequireMessageFunctionalDependencies","page":"Overview","title":"ReactiveMP.RequireMessageFunctionalDependencies","text":"RequireMessageFunctionalDependencies(indices::Tuple, start_with::Tuple)\n\nThe same as DefaultFunctionalDependencies, but in order to compute a message out of some edge also requires the inbound message on the this edge.\n\nArguments\n\nindices::Tuple, tuple of integers, which indicates what edges should require inbound messages\nstart_with::Tuple, tuple of nothing or <:Distribution, which specifies the initial inbound messages for edges in indices\n\nNote: start_with uses setmessage! mechanism, hence, it can be visible by other listeners on the same edge. Explicit call to setmessage! overwrites whatever has been passed in start_with.\n\n@model macro accepts a simplified construction of this pipeline:\n\n@model function some_model()\n    # ...\n    y ~ NormalMeanVariance(x, τ) where {\n        pipeline = RequireMessage(x = vague(NormalMeanPrecision),     τ)\n                                  # ^^^                               ^^^\n                                  # request 'inbound' for 'x'         we may do the same for 'τ',\n                                  # and initialise with `vague(...)`  but here we skip initialisation\n    }\n    # ...\nend\n\nDeprecation warning: RequireInboundFunctionalDependencies has been deprecated in favor of RequireMessageFunctionalDependencies.\n\nSee also: ReactiveMP.DefaultFunctionalDependencies, ReactiveMP.RequireMarginalFunctionalDependencies, ReactiveMP.RequireEverythingFunctionalDependencies\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/nodes/#ReactiveMP.RequireMarginalFunctionalDependencies","page":"Overview","title":"ReactiveMP.RequireMarginalFunctionalDependencies","text":"RequireMarginalFunctionalDependencies(indices::Tuple, start_with::Tuple)\n\nSimilar to DefaultFunctionalDependencies, but in order to compute a message out of some edge also requires the posterior marginal on that edge.\n\nArguments\n\nindices::Tuple, tuple of integers, which indicates what edges should require their own marginals\nstart_with::Tuple, tuple of nothing or <:Distribution, which specifies the initial marginal for edges in indices\n\nNote: start_with uses the setmarginal! mechanism, hence it can be visible to other listeners on the same edge. Explicit calls to setmarginal! overwrites whatever has been passed in start_with.\n\n@model macro accepts a simplified construction of this pipeline:\n\n@model function some_model()\n    # ...\n    y ~ NormalMeanVariance(x, τ) where {\n        pipeline = RequireMarginal(x = vague(NormalMeanPrecision),     τ)\n                                   # ^^^                               ^^^\n                                   # request 'marginal' for 'x'        we may do the same for 'τ',\n                                   # and initialise with `vague(...)`  but here we skip initialisation\n    }\n    # ...\nend\n\nNote: The simplified construction in @model macro syntax is only available in GraphPPL.jl of version >2.2.0.\n\nSee also: ReactiveMP.DefaultFunctionalDependencies, ReactiveMP.RequireMessageFunctionalDependencies, ReactiveMP.RequireEverythingFunctionalDependencies\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/nodes/#ReactiveMP.RequireEverythingFunctionalDependencies","page":"Overview","title":"ReactiveMP.RequireEverythingFunctionalDependencies","text":"RequireEverythingFunctionalDependencies\n\nThis pipeline specifies that in order to compute a message of some edge update rules request everything that is available locally. This includes all inbound messages (including on the same edge) and marginals over all local edge-clusters (this may or may not include marginals on single edges, depends on the local factorisation constraint).\n\nSee also: DefaultFunctionalDependencies, RequireMessageFunctionalDependencies, RequireMarginalFunctionalDependencies\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/nodes/#lib-node-traits","page":"Overview","title":"Node traits","text":"","category":"section"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"Each factor node has to define the as_node_functional_form trait function and to specify a ValidNodeFunctionalForm singleton as a return object. By default as_node_functional_form returns UndefinedNodeFunctionalForm. Objects that do not specify this property correctly cannot be used in model specification.","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"note: Note\n@node macro does that automatically","category":"page"},{"location":"lib/nodes/nodes/","page":"Overview","title":"Overview","text":"ReactiveMP.ValidNodeFunctionalForm\nReactiveMP.UndefinedNodeFunctionalForm\nReactiveMP.as_node_functional_form","category":"page"},{"location":"lib/nodes/nodes/#ReactiveMP.ValidNodeFunctionalForm","page":"Overview","title":"ReactiveMP.ValidNodeFunctionalForm","text":"ValidNodeFunctionalForm\n\nTrait specification for an object that can be used in model specification as a factor node.\n\nSee also: as_node_functional_form, UndefinedNodeFunctionalForm\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/nodes/#ReactiveMP.UndefinedNodeFunctionalForm","page":"Overview","title":"ReactiveMP.UndefinedNodeFunctionalForm","text":"UndefinedNodeFunctionalForm\n\nTrait specification for an object that can not be used in model specification as a factor node.\n\nSee also: as_node_functional_form, ValidNodeFunctionalForm\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/nodes/#ReactiveMP.as_node_functional_form","page":"Overview","title":"ReactiveMP.as_node_functional_form","text":"as_node_functional_form(object)\n\nDetermines object node functional form trait specification. Returns either ValidNodeFunctionalForm() or UndefinedNodeFunctionalForm().\n\nSee also: ValidNodeFunctionalForm, UndefinedNodeFunctionalForm\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/flow/#lib-nodes-flow","page":"Flow","title":"Flow node","text":"","category":"section"},{"location":"lib/nodes/flow/","page":"Flow","title":"Flow","text":"See also Flow tutorial for a comprehensive guide on using flows in ReactiveMP.","category":"page"},{"location":"lib/nodes/flow/","page":"Flow","title":"Flow","text":"PlanarFlow\nRadialFlow\nFlowModel\nCompiledFlowModel\ncompile\nAdditiveCouplingLayer\nInputLayer\nPermutationLayer\nFlowMeta","category":"page"},{"location":"lib/nodes/flow/#ReactiveMP.PlanarFlow","page":"Flow","title":"ReactiveMP.PlanarFlow","text":"The PlanarFlow function is defined as\n\nf(bfx) = bfx + bfu tanh(bfw^top bfx + b)\n\nwith input and output dimension D. Here bfxin mathbbR^D represents the input of the function. Furthermore bfuin mathbbR^D, bfwin mathbbR^D and binmathbbR represent the parameters of the function. The function contracts and expands the input space. \n\nThis function has been introduced in:\n\nRezende, Danilo, and Shakir Mohamed. \"Variational inference with normalizing flows.\" International conference on machine learning. PMLR, 2015.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/flow/#ReactiveMP.RadialFlow","page":"Flow","title":"ReactiveMP.RadialFlow","text":"The RadialFlow function is defined as\n\nf(bfx) = bfx + fracbeta(bfz - bfz_0)alpha + bfz - bfz_0\n\nwith input and output dimension D. Here bfxin mathbbR^D represents the input of the function. Furthermore bfz_0in mathbbR^D, alphain mathbbR and betainmathbbR represent the parameters of the function. The function contracts and expands the input space. \n\nThis function has been introduced in:\n\nRezende, Danilo, and Shakir Mohamed. \"Variational inference with normalizing flows.\" International conference on machine learning. PMLR, 2015.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/flow/#ReactiveMP.FlowModel","page":"Flow","title":"ReactiveMP.FlowModel","text":"The FlowModel structure is the most generic type of Flow model, in which the layers are not constrained to be of a specific type. The FlowModel structure contains the input dimensionality and a tuple of layers and can be constructed as FlowModel( dim, (layer1, layer2, ...) ).\n\nNote: this model can be specialized by constraining the types of layers. This potentially allows for more efficient specialized methods that can deal with specifics of these layers, such as triangular jacobian matrices.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/flow/#ReactiveMP.CompiledFlowModel","page":"Flow","title":"ReactiveMP.CompiledFlowModel","text":"The CompiledFlowModel structure is the most generic type of compiled Flow model, in which the layers are not constrained to be of a specific type. The FlowModel structure contains the input dimension and a tuple of compiled layers. Do not manually create a CompiledFlowModel! Instead create a FlowModel first and compile it with compile(model::FlowModel). This will make sure that all layers/mappings are configured with the proper dimensionality and with randomly sampled parameters. Alternatively, if you would like to pass your own parameters, call compile(model::FlowModel, params::Vector).\n\nNote: this model can be specialized by constraining the types of layers. This potentially allows for more efficient specialized methods that can deal with specifics of these layers, such as triangular jacobian matrices.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/flow/#ReactiveMP.compile","page":"Flow","title":"ReactiveMP.compile","text":"compile() compiles a model by setting its parameters. It randomly sets parameter values in the layers and flows such that inference in the model can be obtained.\n\nInput arguments\n\nmodel::FlowModel - a model of which the dimensionality of its layers/flows has been initialized, but its parameters have not been set.\n\nReturn arguments\n\n::CompiledFlowModel - a compiled model with set parameters, such that it can be used for processing data.\n\n\n\n\n\ncompile(model::FlowModel, params::Vector) lets you initialize a model model with a vector of parameters params.\n\nInput arguments\n\nmodel::FlowModel - a model of which the dimensionality of its layers/flows has been initialized, but its parameters have not been set.\nparams::Vector   - a vector of parameters with which the model should be compiled.\n\nReturn arguments\n\n::CompiledFlowModel - a compiled model with set parameters, such that it can be used for processing data.\n\n\n\n\n\n","category":"function"},{"location":"lib/nodes/flow/#ReactiveMP.AdditiveCouplingLayer","page":"Flow","title":"ReactiveMP.AdditiveCouplingLayer","text":"The additive coupling layer specifies an invertible function bfy = g(bfx) following the specific structure (for the mapping g mathbbR^2 rightarrow mathbbR^2):\n\n    beginalign\n        y_1 = x_1 \n        y_2 = x_2 + f(x_1)\n    endalign\n\nwhere f(cdot) denotes an arbitrary function with mapping f mathbbR rightarrow mathbbR. This function can be chosen arbitrarily complex. Non-linear functions (neural networks) are often chosen to model complex relationships. From the definition of the model, invertibility can be easily achieved as\n\n    beginalign\n        x_1 = y_1 \n        x_2 = y_2 - f(y_1)\n    endalign\n\nThe current implementation only allows for the mapping g mathbbR^2 rightarrow mathbbR^2, although this layer can be generalized for arbitrary input dimensions.\n\nAdditiveCouplingLayer(f <: AbstractCouplingFlow) creates the layer structure with function f.\n\nExample\n\nf = PlanarFlow()\nlayer = AdditiveCouplingLayer(f)\n\nThis layer structure has been introduced in:\n\nDinh, Laurent, David Krueger, and Yoshua Bengio. \"Nice: Non-linear independent components estimation.\" arXiv preprint arXiv:1410.8516 (2014).\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/flow/#ReactiveMP.InputLayer","page":"Flow","title":"ReactiveMP.InputLayer","text":"The input layer specifies the input dimension to a flow model.\n\nlayer = InputLayer(3)\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/flow/#ReactiveMP.PermutationLayer","page":"Flow","title":"ReactiveMP.PermutationLayer","text":"The permutation layer specifies an invertible mapping bfy = g(bfx) = Pbfx where P is a permutation matrix.\n\n\n\n\n\n","category":"type"},{"location":"lib/nodes/flow/#ReactiveMP.FlowMeta","page":"Flow","title":"ReactiveMP.FlowMeta","text":"The FlowMeta structure contains the meta data of the Flow factor node. More specifically, it contains the model of the Flow factor node. The FlowMeta structure can be constructed as FlowMeta(model). Make sure that the flow model has been compiled.\n\nThe FlowMeta structure is required for the Flow factor node and can be included with the Flow node as: y ~ Flow(x) where { meta = FlowMeta(...) }\n\n\n\n\n\n","category":"type"},{"location":"extra/contributing/#Contribution-guidelines","page":"Contributing","title":"Contribution guidelines","text":"","category":"section"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"We welcome all possible contributors. This page details the some of the guidelines that should be followed when contributing to this package.","category":"page"},{"location":"extra/contributing/#Reporting-bugs","page":"Contributing","title":"Reporting bugs","text":"","category":"section"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"We track bugs using GitHub issues. We encourage you to write complete, specific, reproducible bug reports. Mention the versions of Julia and ReactiveMP for which you observe unexpected behavior. Please provide a concise description of the problem and complement it with code snippets, test cases, screenshots, tracebacks or any other information that you consider relevant. This will help us to replicate the problem and narrow the search space for solutions.","category":"page"},{"location":"extra/contributing/#Suggesting-features","page":"Contributing","title":"Suggesting features","text":"","category":"section"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"We welcome new feature proposals. However, before submitting a feature request, consider a few things:","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"Does the feature require changes in the core ReactiveMP.jl code? If it doesn't (for example, you would like to add a factor node for a particular application), you can add local extensions in your script/notebook or consider making a separate repository for your extensions.\nIf you would like to add an implementation of a feature that changes a lot in the core ReactiveMP.jl code, please open an issue on GitHub and describe your proposal first. This will allow us to discuss your proposal with you before you invest your time in implementing something that may be difficult to merge later on.","category":"page"},{"location":"extra/contributing/#Contributing-code","page":"Contributing","title":"Contributing code","text":"","category":"section"},{"location":"extra/contributing/#Installing-ReactiveMP","page":"Contributing","title":"Installing ReactiveMP","text":"","category":"section"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"We suggest that you use the dev command from the new Julia package manager to install ReactiveMP.jl for development purposes. To work on your fork of ReactiveMP.jl, use your fork's URL address in the dev command, for example:","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"] dev git@github.com:your_username/ReactiveMP.jl.git","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"The dev command clones ReactiveMP.jl to ~/.julia/dev/ReactiveMP. All local changes to ReactiveMP code will be reflected in imported code.","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"note: Note\nIt is also might be useful to install Revise.jl package as it allows you to modify code and use the changes without restarting Julia.","category":"page"},{"location":"extra/contributing/#Committing-code","page":"Contributing","title":"Committing code","text":"","category":"section"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"We use the standard GitHub Flow workflow where all contributions are added through pull requests. In order to contribute, first fork the repository, then commit your contributions to your fork, and then create a pull request on the master branch of the ReactiveMP.jl repository.","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"Before opening a pull request, please make sure that all tests pass without failing! All demos (can be found in /demo/ directory) and benchmarks (can be found in /benchmark/ directory) have to run without errors as well.","category":"page"},{"location":"extra/contributing/#Style-conventions","page":"Contributing","title":"Style conventions","text":"","category":"section"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"note: Note\nReactiveMP.jl repository contains scripts to automatically format code according to our guidelines. Use make format command to fix code style. This command overwrites files.","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"We use default Julia style guide. We list here a few important points and our modifications to the Julia style guide:","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"Use 4 spaces for indentation\nType names use UpperCamelCase. For example: AbstractFactorNode, RandomVariable, etc..\nFunction names are lowercase with underscores, when necessary. For example: activate!, randomvar, as_variable, etc..\nVariable names and function arguments use snake_case\nThe name of a method that modifies its argument(s) must end in !","category":"page"},{"location":"extra/contributing/#Unit-tests","page":"Contributing","title":"Unit tests","text":"","category":"section"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"We use the test-driven development (TDD) methodology for ReactiveMP.jl development. The test coverage should be as complete as possible. Please make sure that you write tests for each piece of code that you want to add.","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"All unit tests are located in the /test/ directory. The /test/ directory follows the structure of the /src/ directory. Each test file should have following filename format: test_*.jl. Some tests are also present in jldoctest docs annotations directly in the source code. See Julia's documentation about doctests.","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"The tests can be evaluated by running following command in the Julia REPL:","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"] test ReactiveMP","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"In addition tests can be evaluated by running following command in the ReactiveMP root directory:","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"make test","category":"page"},{"location":"extra/contributing/#Fixes-to-external-libraries","page":"Contributing","title":"Fixes to external libraries","text":"","category":"section"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"If a bug has been discovered in an external dependencies of the ReactiveMP.jl it is the best to open an issue  directly in the dependency's github repository. You use can use the fixes.jl file for hot-fixes before  a new release of the broken dependecy is available.","category":"page"},{"location":"extra/contributing/#Makefile","page":"Contributing","title":"Makefile","text":"","category":"section"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"ReactiveMP.jl uses Makefile for most common operations:","category":"page"},{"location":"extra/contributing/","page":"Contributing","title":"Contributing","text":"make help: Shows help snippet\nmake test: Run tests, supports extra arguments\nmake test test_args=\"distributions:normal_mean_variance\" would run tests only from distributions/test_normal_mean_variance.jl\nmake test test_args=\"distributions:normal_mean_variance models:lgssm\" would run tests both from distributions/test_normal_mean_variance.jl and models/test_lgssm.jl\nmake docs: Compile documentation\nmake benchmark: Run simple benchmark\nmake lint: Check codestyle\nmake format: Check and fix codestyle ","category":"page"},{"location":"lib/prod/#lib-prod","page":"Prod implementation","title":"Prod implementation","text":"","category":"section"},{"location":"lib/prod/","page":"Prod implementation","title":"Prod implementation","text":"prod_analytical_rule\nresolve_prod_constraint\nprod(::ProdAnalytical, left, right)\nProdAnalytical\nProdFinal\nProdPreserveType\nProdPreserveTypeLeft\nProdPreserveTypeRight","category":"page"},{"location":"lib/prod/#ReactiveMP.prod_analytical_rule","page":"Prod implementation","title":"ReactiveMP.prod_analytical_rule","text":"prod_analytical_rule(::Type, ::Type)\n\nReturns either ProdAnalyticalRuleAvailable or ProdAnalyticalRuleUnknown for two given distribution types. Returns ProdAnalyticalRuleUnknown by default.\n\nSee also: prod, ProdAnalytical, ProdGeneric\n\n\n\n\n\n","category":"function"},{"location":"lib/prod/#ReactiveMP.resolve_prod_constraint","page":"Prod implementation","title":"ReactiveMP.resolve_prod_constraint","text":"resolve_prod_constraint(left, right)\n\nGiven two product constraints returns a single one that has a higher priority (if possible).\n\nSee also: prod, ProdAnalytical, ProdGeneric\n\n\n\n\n\n","category":"function"},{"location":"lib/prod/#Base.prod-Tuple{ProdAnalytical, Any, Any}","page":"Prod implementation","title":"Base.prod","text":"prod(strategy, left, right)\n\nprod function is used to find a product of two probability distrubutions (or any other objects) over same variable (e.g. 𝓝(x|μ1, σ1) × 𝓝(x|μ2, σ2)). There are multiple strategies for prod function, e.g. ProdAnalytical, ProdGeneric or ProdPreserveType.\n\nExamples:\n\nusing ReactiveMP\n\nproduct = prod(ProdAnalytical(), NormalMeanVariance(-1.0, 1.0), NormalMeanVariance(1.0, 1.0))\n\nmean(product), var(product)\n\n# output\n(0.0, 0.5)\n\nSee also: prod_analytical_rule, ProdAnalytical, ProdGeneric\n\n\n\n\n\n","category":"method"},{"location":"lib/prod/#ReactiveMP.ProdAnalytical","page":"Prod implementation","title":"ReactiveMP.ProdAnalytical","text":"ProdAnalytical\n\nProdAnalytical is one of the strategies for prod function. This strategy uses analytical prod methods but does not constraint a prod to be in any specific form. It throws an NoAnalyticalProdException if no analytical rules is available, use ProdGeneric prod strategy to fallback to approximation methods.\n\nNote: ProdAnalytical ignores missing values and simply returns the non-missing argument. Returns missing in case if both arguments are missing.\n\nSee also: prod, ProdPreserveType, ProdGeneric\n\n\n\n\n\n","category":"type"},{"location":"lib/prod/#ReactiveMP.ProdFinal","page":"Prod implementation","title":"ReactiveMP.ProdFinal","text":"ProdFinal{T}\n\nThe ProdFinal is a wrapper around a distribution. By passing it as a message along an edge of the graph the corresponding marginal is calculated as the distribution of the ProdFinal.  In a sense, the ProdFinal ignores any further prod with any other distribution for calculating the marginal and only check for variate types of two distributions. Trying to prod two instances of ProdFinal will result in an error. Note: ProdFinal is not a prod strategy, as opposed to ProdAnalytical and ProdGeneric.\n\nSee also: [BIFM]\n\n\n\n\n\n","category":"type"},{"location":"lib/prod/#ReactiveMP.ProdPreserveType","page":"Prod implementation","title":"ReactiveMP.ProdPreserveType","text":"ProdPreserveType{T}\n\nProdPreserveType is one of the strategies for prod function. This strategy constraint an output of a prod to be in some specific form. By default it fallbacks to a ProdAnalytical strategy and converts an output to a prespecified type but can be overwritten for some distributions for better performance.\n\nSee also: prod, ProdAnalytical, ProdPreserveTypeLeft, ProdPreserveTypeRight\n\n\n\n\n\n","category":"type"},{"location":"lib/prod/#ReactiveMP.ProdPreserveTypeLeft","page":"Prod implementation","title":"ReactiveMP.ProdPreserveTypeLeft","text":"ProdPreserveTypeLeft\n\nProdPreserveTypeLeft is one of the strategies for prod function. This strategy constraint an output of a prod to be in the functional form as left argument. By default it fallbacks to a ProdPreserveType strategy and converts an output to a prespecified type but can be overwritten for some distributions for better performance.\n\nSee also: prod, ProdPreserveType, ProdPreserveTypeRight\n\n\n\n\n\n","category":"type"},{"location":"lib/prod/#ReactiveMP.ProdPreserveTypeRight","page":"Prod implementation","title":"ReactiveMP.ProdPreserveTypeRight","text":"ProdPreserveTypeRight\n\nProdPreserveTypeRight is one of the strategies for prod function. This strategy constraint an output of a prod to be in the functional form as right argument. By default it fallbacks to a ProdPreserveType strategy and converts an output to a prespecified type but can be overwritten for some distributions for better performance.\n\nSee also: prod, ProdPreserveType, ProdPreserveTypeLeft\n\n\n\n\n\n","category":"type"},{"location":"lib/prod/#Dist-product","page":"Prod implementation","title":"Dist product","text":"","category":"section"},{"location":"lib/prod/","page":"Prod implementation","title":"Prod implementation","text":"DistProduct\nProdGeneric\nGenericLogPdfVectorisedProduct","category":"page"},{"location":"lib/prod/#ReactiveMP.DistProduct","page":"Prod implementation","title":"ReactiveMP.DistProduct","text":"DistProduct\n\nIf inference backend cannot return an analytical solution for a product of two distributions it may fallback to the DistProduct structure DistProduct is useful to propagate the exact forms of two messages until it hits some approximation method for form-constraint. However DistProduct cannot be used to compute statistics such as mean or variance.  It has to be approximated before using in actual inference procedure.\n\nBackend exploits form constraints specification which usually help to deal with intractable distributions products. \n\nSee also: prod, ProdGeneric\n\n\n\n\n\n","category":"type"},{"location":"lib/prod/#ReactiveMP.ProdGeneric","page":"Prod implementation","title":"ReactiveMP.ProdGeneric","text":"ProdGeneric{C}\n\nProdGeneric is one of the strategies for prod function. This strategy does not fail in case of no analytical rule is available, but simply creates a product tree, there all nodes represent the prod function and all leaves are valid Distribution object. This object does not define any statistical properties (such as mean or var etc) and cannot be used during the inference procedure. However this object plays imporant part in the functional form constraints implementation.  In a few words this object keeps all the information of a product of messages and propagates this information in the functional form constraint.\n\nProdGeneric has a \"fallback\" method, which it may or may not use under some circumstances. For example if the fallback method is ProdAnalytical (which is the default one) - ProdGeneric will try to optimize prod tree with analytical solutions where possible.\n\nSee also: prod, DistProduct, ProdAnalytical, ProdPreserveType, prod_analytical_rule, GenericLogPdfVectorisedProduct\n\n\n\n\n\n","category":"type"},{"location":"lib/prod/#ReactiveMP.GenericLogPdfVectorisedProduct","page":"Prod implementation","title":"ReactiveMP.GenericLogPdfVectorisedProduct","text":"GenericLogPdfVectorisedProduct\n\nAn efficient linearized implementation of product of multiple generic log-pdf objects. This structure prevents DistProduct tree from growing too much in case of identical log-pdf objects.  This trick significantly reduces Julia compilation times when analytical product rules are not available but messages are of the same type. Essentially this structure linearizes leafes of the DistProduct tree in case if it sees objects of the same type (via dispatch).\n\nSee also: DistProduct\n\n\n\n\n\n","category":"type"},{"location":"custom/custom-functional-form/#custom-functional-form","page":"Custom functional form","title":"Custom Functional Form Specification","text":"","category":"section"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"In a nutshell, functional form constraints defines a function that approximates the product of colliding messages and computes posterior marginal that can be used later on during the inference procedure. An important part of the functional forms constraint implementation is the prod function. More information about prod function is present in the Prod Implementation section. For example, if we refer to our CustomFunctionalForm as to f we can see the whole functional form constraints pipeline as:","category":"page"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"q(x) = fleft(fracoverrightarrowmu(x)overleftarrowmu(x)int overrightarrowmu(x)overleftarrowmu(x) mathrmdxright)","category":"page"},{"location":"custom/custom-functional-form/#Interface","page":"Custom functional form","title":"Interface","text":"","category":"section"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"ReactiveMP.jl, however, uses some extra utility functions to define functional form constraint behaviour. Here we briefly describe all utility function. If you are only interested in the concrete example, you may directly head to the Custom Functional Form example at the end of this section.","category":"page"},{"location":"custom/custom-functional-form/#Abstract-super-type","page":"Custom functional form","title":"Abstract super type","text":"","category":"section"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"AbstractFormConstraint","category":"page"},{"location":"custom/custom-functional-form/#ReactiveMP.AbstractFormConstraint","page":"Custom functional form","title":"ReactiveMP.AbstractFormConstraint","text":"AbstractFormConstraint\n\nEvery functional form constraint is a subtype of AbstractFormConstraint abstract type.\n\nNote: this is not strictly necessary, but it makes automatic dispatch easier and compatible with the CompositeFormConstraint.\n\nSee also: CompositeFormConstraint\n\n\n\n\n\n","category":"type"},{"location":"custom/custom-functional-form/#Form-check-strategy","page":"Custom functional form","title":"Form check strategy","text":"","category":"section"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"Every custom functional form must implement a new method for the default_form_check_strategy function that returns either FormConstraintCheckEach or FormConstraintCheckLast.","category":"page"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"FormConstraintCheckLast: q(x) = f(μ1(x) * μ2(x) * μ3(x))\nFormConstraintCheckEach: q(x) = f(f(μ1(x) * μ2(x)) * μ3(x))","category":"page"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"default_form_check_strategy\nFormConstraintCheckEach\nFormConstraintCheckLast","category":"page"},{"location":"custom/custom-functional-form/#ReactiveMP.default_form_check_strategy","page":"Custom functional form","title":"ReactiveMP.default_form_check_strategy","text":"default_form_check_strategy(form_constraint)\n\nReturns a default check strategy (e.g. FormConstraintCheckEach or FormConstraintCheckEach) for a given form constraint object.\n\nSee also: FormConstraintCheckEach, FormConstraintCheckLast, constrain_form\n\n\n\n\n\n","category":"function"},{"location":"custom/custom-functional-form/#ReactiveMP.FormConstraintCheckEach","page":"Custom functional form","title":"ReactiveMP.FormConstraintCheckEach","text":"FormConstraintCheckEach\n\nThis form constraint check strategy checks functional form of the messages product after each product in an equality chain.  Usually if a variable has been connected to multiple nodes we want to perform multiple prod to obtain a posterior marginal. With this form check strategy constrain_form function will be executed after each subsequent prod function.\n\nSee also: FormConstraintCheckLast, default_form_check_strategy, constrain_form, multiply_messages\n\n\n\n\n\n","category":"type"},{"location":"custom/custom-functional-form/#ReactiveMP.FormConstraintCheckLast","page":"Custom functional form","title":"ReactiveMP.FormConstraintCheckLast","text":"FormConstraintCheckEach\n\nThis form constraint check strategy checks functional form of the last messages product in the equality chain.  Usually if a variable has been connected to multiple nodes we want to perform multiple prod to obtain a posterior marginal. With this form check strategy constrain_form function will be executed only once after all subsequenct prod functions have been executed.\n\nSee also: FormConstraintCheckLast, default_form_check_strategy, constrain_form, multiply_messages\n\n\n\n\n\n","category":"type"},{"location":"custom/custom-functional-form/#Prod-constraint","page":"Custom functional form","title":"Prod constraint","text":"","category":"section"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"Every custom functional form must implement a new method for the default_prod_constraint function that returns a proper prod_constraint object.","category":"page"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"default_prod_constraint","category":"page"},{"location":"custom/custom-functional-form/#ReactiveMP.default_prod_constraint","page":"Custom functional form","title":"ReactiveMP.default_prod_constraint","text":"default_prod_constraint(form_constraint)\n\nReturns a default prod constraint needed to apply a given form_constraint. For most form constraints this function returns ProdGeneric.\n\nSee also: ProdAnalytical, ProdGeneric\n\n\n\n\n\n","category":"function"},{"location":"custom/custom-functional-form/#Constrain-form,-a.k.a-f","page":"Custom functional form","title":"Constrain form, a.k.a f","text":"","category":"section"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"The main function that a custom functional form must implement, which we referred to as f in the beginning of this section, is the constrain_form function.","category":"page"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"constrain_form","category":"page"},{"location":"custom/custom-functional-form/#ReactiveMP.constrain_form","page":"Custom functional form","title":"ReactiveMP.constrain_form","text":"constrain_form(form_constraint, distribution)\n\nThis function must approximate distribution object in a form that satisfies form_constraint.\n\nSee also: FormConstraintCheckEach, FormConstraintCheckLast, default_form_check_strategy, is_point_mass_form_constraint\n\n\n\n\n\n","category":"function"},{"location":"custom/custom-functional-form/#Is-point-mass-form-constraint-(optional)","page":"Custom functional form","title":"Is point mass form constraint (optional)","text":"","category":"section"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"Every custom functional form may implement a new method for the is_point_mass_form_constraint function that returns either true or false. This is an utility function that simplifes computation of the Bethe Free Energy and is not strictly necessary.","category":"page"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"is_point_mass_form_constraint","category":"page"},{"location":"custom/custom-functional-form/#ReactiveMP.is_point_mass_form_constraint","page":"Custom functional form","title":"ReactiveMP.is_point_mass_form_constraint","text":"is_point_mass_form_constraint(form_constraint)\n\nSpecifies whether form constraint always returns PointMass estimates or not. For a given form_constraint returns either true or false.\n\nSee also: FormConstraintCheckEach, FormConstraintCheckLast, constrain_form\n\n\n\n\n\n","category":"function"},{"location":"custom/custom-functional-form/#Compatibility-with-@constraints-macro-(optional)","page":"Custom functional form","title":"Compatibility with @constraints macro (optional)","text":"","category":"section"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"To make custom functional form constraint compatible with the @constraints macro, it must implement a new method for the make_form_constraint function.","category":"page"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"make_form_constraint","category":"page"},{"location":"custom/custom-functional-form/#ReactiveMP.make_form_constraint","page":"Custom functional form","title":"ReactiveMP.make_form_constraint","text":"make_form_constraint(::Type, args...; kwargs...)\n\nCreates form constraint object based on passed type with given args and kwargs. Used to simplify form constraint specification.\n\nAs an example:\n\nmake_form_constraint(PointMass)\n\ncreates an instance of PointMassFormConstraint and \n\nmake_form_constraint(SampleList, 5000, LeftProposal())\n\nshould create an instance of SampleListFormConstraint.\n\nSee also: AbstractFormConstraint\n\n\n\n\n\n","category":"function"},{"location":"custom/custom-functional-form/#custom-functional-form-example","page":"Custom functional form","title":"Custom Functional Form Example","text":"","category":"section"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"In this demo we show how to build a custom functional form constraint that is compatible with the ReactiveMP.jl inference backend. An important part of the functional forms constraint implementation is the prod function. More information about prod function is present in the Prod Implementation section. We show a relatively simple use-case, which might not be very useful in practice, but serves as a simple step-by-step guide. Assume that we want a specific posterior marginal of some random variable in our model to have a specific Gaussian parametrisation, for example mean-precision. We can use built-in NormalMeanPrecision distribution, but we still need to define our custom functional form constraint:","category":"page"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"using ReactiveMP\n\n# First we define our functional form structure with no fields\nstruct MeanPrecisionFormConstraint <: AbstractFormConstraint end","category":"page"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"Next we define the behaviour of our functional form constraint:","category":"page"},{"location":"custom/custom-functional-form/","page":"Custom functional form","title":"Custom functional form","text":"ReactiveMP.is_point_mass_form_constraint(::MeanPrecisionFormConstraint) = false\nReactiveMP.default_form_check_strategy(::MeanPrecisionFormConstraint)   = FormConstraintCheckLast()\nReactiveMP.default_prod_constraint(::MeanPrecisionFormConstraint)       = ProdGeneric()\n\nfunction ReactiveMP.constrain_form(::MeanPrecisionFormConstraint, distribution) \n    # This is quite a naive assumption, that a given `dsitribution` object has `mean` and `precision` defined\n    # However this quantities might be approximated with some other external method, e.g. Laplace approximation\n    m = mean(distribution)      # or approximate with some other method\n    p = precision(distribution) # or approximate with some other method\n    return NormalMeanPrecision(m, p)\nend\n\nfunction ReactiveMP.constrain_form(::MeanPrecisionFormConstraint, distribution::DistProduct)\n    # DistProduct is the special case, read about this type more in the corresponding documentation section\n    # ... \nend","category":"page"},{"location":"custom/custom-addons/#custom-addons","page":"Custom addons","title":"Custom Addons","text":"","category":"section"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"Standard message passing schemes only pass along distributions to other nodes. However, for more advanced usage, there might be a need for passing along additional information in messages and/or marginals. One can for example think of passing along the scaling of the distribution or some information that specifies how the message or marginal was computed, i.e. which messages were used for its computation and which node was preceding it. Another use cases is saving extra debugging information inside messages themselves, e.g. what arguments have been used to compute a message.","category":"page"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"Addons provide a solution here. Basically, addons are structures that contain extra information that are passed along the graph with messages and marginals in a tuple. These addons can be extracted using the getaddons(message/marginal) function. Its usage and operations can differ significantly for each application, yet below gives a concise overview on how to implement them on your own.","category":"page"},{"location":"custom/custom-addons/#Example","page":"Custom addons","title":"Example","text":"","category":"section"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"Suppose that we wish to create an addon that counts the number of computations that preceded some message or marginal. This addon can be created by adding the file src/addons/count.jl and by including it in the ReactiveMP.jl file.","category":"page"},{"location":"custom/custom-addons/#Step-1:-Creating-the-addon-structure","page":"Custom addons","title":"Step 1: Creating the addon structure","text":"","category":"section"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"Let's start by defining our new addon structure. This might seem daunting, but basically only requires us to specify the information that we would like to collect. Just make sure that it is specified as a subtype of AbstractAddon. In our example this becomes:","category":"page"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"struct AddonCount{T} <: AbstractAddon\n    count :: T\nend","category":"page"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"You can add additional fields or functions for improved handling, such as get_count() or show() functions.","category":"page"},{"location":"custom/custom-addons/#Step-2:-Compute-addon-value-after-computing-a-message","page":"Custom addons","title":"Step 2: Compute addon value after computing a message","text":"","category":"section"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"As a second step we need to specify how the addon behaves when a new message is computed in a factor node.  For this purpose we need to implement a specialized version of the message_mapping_addon() function. This function accepts the mapping variables of the factor node and updates the addons by extending the tuple.","category":"page"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"In our example we could write","category":"page"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"# This specification assumes that the default value for addon is `AddonCount(nothing)`\nfunction message_mapping_addon(::AddonCount{Nothing}, mapping, messages, marginals, result, addons)\n\n    # get number of operations of messages\n    message_count = 0\n    for message in messages\n        message_count += getcount(message)\n    end\n\n    # get number of operations of marginals\n    marginal_count = 0\n    for marginal in marginals\n        marginal_count += getcount(marginal)\n    end\n\n    # extend addons with AddonCount() structure\n    return AddonCount(message_count + marginal_count + 1)\nend\n","category":"page"},{"location":"custom/custom-addons/#Step-3:-Computing-products","page":"Custom addons","title":"Step 3: Computing products","text":"","category":"section"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"The goal is to update the AddonCount structure when we multiply 2 messages. As a result, we need to write a function that allows us to define this behaviour. This function is called multiply_addons and accepts 5 arguments. In our example this becomes","category":"page"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"function multiply_addons(left_addon::AddonCount, right_addon::AddonCount, new_dist, left_dist, right_dist)\n    return AddonCount(left_addon.count + right_addon.count + 1)\nend","category":"page"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"here we add the number of operations from the addons that are being multiplied and we add one (for the current operation). we are aware that this is likely not valid for iterative message passing schemes, but it still serves as a nice example. the left_addon and right_addon argument specify the addoncount objects that are being multiplied. corresponding to these addons, there are the distributions left_dist and right_dist, which might contain information for computing the product. the new distribution new_dist ∝ left_dist * right_dist is also passed along for potentially reusing the result of earlier computations.","category":"page"},{"location":"custom/custom-addons/#More-information","page":"Custom addons","title":"More information","text":"","category":"section"},{"location":"custom/custom-addons/","page":"Custom addons","title":"Custom addons","text":"For more advanced information check the implementation of the log-scale or memory addons.","category":"page"},{"location":"lib/methods/#lib-using-methods","page":"Exported methods","title":"Using methods from ReactiveMP","text":"","category":"section"},{"location":"lib/methods/","page":"Exported methods","title":"Exported methods","text":"In the Julia programming language (in contrast to Python for example) the most common way of loading a module is:","category":"page"},{"location":"lib/methods/","page":"Exported methods","title":"Exported methods","text":"using ReactiveMP","category":"page"},{"location":"lib/methods/","page":"Exported methods","title":"Exported methods","text":"A nice explanation about how modules/packages work in Julia can be found in the official documentation.","category":"page"},{"location":"lib/methods/","page":"Exported methods","title":"Exported methods","text":"In a nutshell, Julia automatically resolves all name collisions and there is no a lot of benefit of importing specific names, e.g.:","category":"page"},{"location":"lib/methods/","page":"Exported methods","title":"Exported methods","text":"import ReactiveMP: mean","category":"page"},{"location":"lib/methods/","page":"Exported methods","title":"Exported methods","text":"One of the reasons for that is that Julia uses multiple-dispatch capabilities to merge names automatically and will indicate (with a warning) if something went wrong or names have unresolvable collisions on types. As a small example of this feature consider the following small import example:","category":"page"},{"location":"lib/methods/","page":"Exported methods","title":"Exported methods","text":"import ReactiveMP: mean as mean_from_reactivemp\nimport Distributions: mean as mean_from_distributions\n\nmean_from_reactivemp === mean_from_distributions","category":"page"},{"location":"lib/methods/","page":"Exported methods","title":"Exported methods","text":"Even though we import mean function from two different packages they actually refer to the same object. Worth noting that this is not always the case - Julia will print a warning in case it finds unresolvable conflicts and usage of such functions will be disallowed unless user import them specifically. Read more about this in the section of the Julia's documentation.","category":"page"},{"location":"lib/methods/","page":"Exported methods","title":"Exported methods","text":"# It is easier to let Julia resolve names automatically\n# Julia will not overwrite `mean` that is coming from both packages\nusing ReactiveMP, Distributions ","category":"page"},{"location":"lib/methods/","page":"Exported methods","title":"Exported methods","text":"mean(Normal(0.0, 1.0)) # `Normal` is an object from `Distributions.jl`","category":"page"},{"location":"lib/methods/","page":"Exported methods","title":"Exported methods","text":"mean(NormalMeanVariance(0.0, 1.0)) # `NormalMeanVariance` is an object from `ReactiveMP.jl`","category":"page"},{"location":"lib/methods/#lib-list-methods","page":"Exported methods","title":"List of available methods","text":"","category":"section"},{"location":"lib/methods/","page":"Exported methods","title":"Exported methods","text":"Below you can find a list of exported methods from ReactiveMP.jl. All methods (even private) can be always accessed with ReactiveMP. prefix, e.g ReactiveMP.mean.","category":"page"},{"location":"lib/methods/","page":"Exported methods","title":"Exported methods","text":"note: Note\nSome exported names are (for legacy reasons) intended for private usage only. As a result some of these methods do not have a proper associated documentation with them. We constantly improve ReactiveMP.jl library and continue to add better documentation for many exported methods, but a small portion of these methods could be removed from this list in the future.","category":"page"},{"location":"lib/methods/","page":"Exported methods","title":"Exported methods","text":"using ReactiveMP #hide\nforeach(println, names(ReactiveMP))","category":"page"},{"location":"#ReactiveMP.jl","page":"Introduction","title":"ReactiveMP.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Julia package for reactive message passing Bayesian inference engine on a factor graph.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nThis package exports only an inference engine, for the full ecosystem with convenient model and constraints specification we refer user to the RxInfer.jl package and its documentation.","category":"page"},{"location":"#Examples-and-tutorials","page":"Introduction","title":"Examples and tutorials","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Tutorials and examples are available in the RxInfer documentation.","category":"page"},{"location":"#Table-of-Contents","page":"Introduction","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\n  \"lib/message.md\",\n  \"lib/node.md\",\n  \"lib/math.md\",\n  \"extra/contributing.md\"\n]\nDepth = 2","category":"page"},{"location":"#Index","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"lib/algebra/common/#lib-helpers-algebra-common","page":"Common","title":"Algebra common utilities","text":"","category":"section"},{"location":"lib/algebra/common/#lib-helpers-algebra-diageye","page":"Common","title":"diageye","text":"","category":"section"},{"location":"lib/algebra/common/","page":"Common","title":"Common","text":"diageye","category":"page"},{"location":"lib/algebra/common/#ReactiveMP.diageye","page":"Common","title":"ReactiveMP.diageye","text":"diageye(::Type{T}, n::Int)\n\nAn alias for the Matrix{T}(I, n, n). Returns a matrix of size n x n with ones (of type T) on the diagonal and zeros everywhere else.\n\n\n\n\n\ndiageye(n::Int)\n\nAn alias for the Matrix{Float64}(I, n, n). Returns a matrix of size n x n with ones (of type Float64) on the diagonal and zeros everywhere else.\n\n\n\n\n\n","category":"function"}]
}
