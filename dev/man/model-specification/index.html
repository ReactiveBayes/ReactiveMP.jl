<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Model Specification · ReactiveMP.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><script src="../../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ReactiveMP.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">User guide</span><ul><li><a class="tocitem" href="../getting-started/">Getting Started</a></li><li><a class="tocitem" href="../fundamentals/">Fundamentals</a></li><li class="is-active"><a class="tocitem" href>Model Specification</a><ul class="internal"><li><a class="tocitem" href="#@model-macro"><span><code>@model</code> macro</span></a></li><li><a class="tocitem" href="#A-full-example-before-diving-in"><span>A full example before diving in</span></a></li><li><a class="tocitem" href="#Model-variables"><span>Model variables</span></a></li><li><a class="tocitem" href="#Factor-nodes"><span>Factor nodes</span></a></li></ul></li><li><a class="tocitem" href="../inference-execution/">Inference execution</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/overview/">Overview</a></li><li><a class="tocitem" href="../../examples/linear_gaussian_state_space_model/">Linear Gaussian Dynamical System</a></li><li><a class="tocitem" href="../../examples/hierarchical_gaussian_filter/">Hierarchical Gaussian Filter</a></li><li><a class="tocitem" href="../../examples/autoregressive/">Autoregressive Model</a></li><li><a class="tocitem" href="../../examples/flow_tutorial/">Flow Tutorial</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/message/">Messages</a></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Factor nodes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lib/node/">Overview</a></li><li><a class="tocitem" href="../../lib/nodes/flow/">Flow</a></li></ul></li><li><a class="tocitem" href="../../lib/math/">Math utils</a></li></ul></li><li><a class="tocitem" href="../../extra/contributing/">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User guide</a></li><li class="is-active"><a href>Model Specification</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Model Specification</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/biaslab/ReactiveMP.jl/blob/master/docs/src/man/model-specification.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="user-guide-model-specification"><a class="docs-heading-anchor" href="#user-guide-model-specification">Model Specification</a><a id="user-guide-model-specification-1"></a><a class="docs-heading-anchor-permalink" href="#user-guide-model-specification" title="Permalink"></a></h1><p>Probabilistic models incorporate elements of randomness to describe an event or phenomenon by using random variables and probability theory. A probabilistic model can be represented visually by using probabilistic graphical models (PGMs). A factor graph is a type of PGM that is well suited to cast inference tasks in terms of graphical manipulations.</p><p><code>GraphPPL.jl</code> is a Julia package presenting a model specification language for probabilistic models.</p><h2 id="@model-macro"><a class="docs-heading-anchor" href="#@model-macro"><code>@model</code> macro</a><a id="@model-macro-1"></a><a class="docs-heading-anchor-permalink" href="#@model-macro" title="Permalink"></a></h2><p>The <code>ReactiveMP</code> uses <code>GraphPPL</code> library to simplify model specification. It is not necessary but highly recommended to use <code>ReactiveMP</code> in a combination with <code>GraphPPL</code> model specification library. The <code>GraphPPL</code> library exports a single <code>@model</code> macro for model specification. The <code>@model</code> macro accepts two arguments: model options (optionally) and the model specification itself in a form of regular Julia function. </p><p>For example: </p><pre><code class="language-julia hljs"># `@model` macro accepts an array of named options as a first argument and
# a regular Julia function body as its second argument
@model [ option1 = ..., option2 = ... ] function model_name(model_arguments...)
    # model specification goes here
    return ...
end</code></pre><p>Model options are optional and may be omitted:</p><pre><code class="language-julia hljs">@model function model_name(model_arguments...)
    # model specification here
    return ...
end</code></pre><p>that is equivalent to </p><pre><code class="language-julia hljs"># Empty options if ommited
@model [] function model_name(model_arguments...)
    # model specification here
    return ...
end</code></pre><p>The <code>@model</code> macro returns a regular Julia function (in this example <code>model_name(model_arguments...)</code>) that has the same signature and can be executed as usual. It returns a reference to a model object itself and a tuple of a user specified return variables, e.g:</p><pre><code class="language-julia hljs">@model function my_model(model_arguments...)
    # model specification here
    # ...
    return x, y
end</code></pre><pre><code class="language-julia hljs">model, (x, y) = my_model(model_arguments...)</code></pre><p>It is also important to note that any model should return something, such as variables or nodes. If a model doesn&#39;t return anything then an error will be raised during runtime.  <code>model</code> object might be useful to inspect model&#39;s factor graph and/or factor nodes and variables. It is also used in Bethe Free Energy score computation. If not needed it can be ommited with <code>_</code> placeholder, eg:</p><pre><code class="language-julia hljs">_, (x, y) = my_model(model_arguments...)</code></pre><h2 id="A-full-example-before-diving-in"><a class="docs-heading-anchor" href="#A-full-example-before-diving-in">A full example before diving in</a><a id="A-full-example-before-diving-in-1"></a><a class="docs-heading-anchor-permalink" href="#A-full-example-before-diving-in" title="Permalink"></a></h2><p>Before presenting the details of the model specification syntax, we show an example of a simple probabilistic model. Here we create a linear gaussian state space model with latent random variables <code>x</code> and noisy observations <code>y</code>:</p><pre><code class="language-julia hljs">@model [ options... ] function state_space_model(n_observations, noise_variance)

    x = randomvar(n_observations)
    y = datavar(Float64, n_observations)

    x[1] ~ NormalMeanVariance(0.0, 100.0)

    for i in 2:n_observations
       x[i] ~ x[i - 1] + 1.0
       y[i] ~ NormalMeanVariance(x[i], noise_variance)
    end

    return x, y
end</code></pre><h2 id="Model-variables"><a class="docs-heading-anchor" href="#Model-variables">Model variables</a><a id="Model-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Model-variables" title="Permalink"></a></h2><h3 id="Constants"><a class="docs-heading-anchor" href="#Constants">Constants</a><a id="Constants-1"></a><a class="docs-heading-anchor-permalink" href="#Constants" title="Permalink"></a></h3><p>Any runtime constant passed to a model as a model argument will be automatically converted to a fixed constant in the graph model. This convertion happens every time when model specification identifies a constant. Sometimes it might be useful to create constants by hand (e.g. to avoid copying large matrices across the model and to avoid extensive memory allocations).</p><p>You can create a constant within a model specification macro with <code>constvar()</code> function. For example:</p><pre><code class="language-julia hljs">c = constvar(1.0)

for i in 2:n
    x[i] ~ x[i - 1] + c # Reuse the same reference to a constant 1.0
end</code></pre><p>Additionally you can specify an extra <code>::ConstVariable</code> type for some of the model arguments. In this case macro automatically converts them to a single constant using <code>constvar()</code> function. E.g.:</p><pre><code class="language-julia hljs">@model function model_name(nsamples::Int, c::ConstVariable)
    # ...
    # no need to call for a constvar() here
    for i in 2:n
        x[i] ~ x[i - 1] + c # Reuse the same reference to a constant `c`
    end
    # ...
    return ...
end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>::ConstVariable</code> does not restrict an input type of an argument and does not interfere with multiple dispatch. In this example <code>c</code> can have any type, e.g. <code>Int</code>.</p></div></div><h3 id="user-guide-model-specification-data-variables"><a class="docs-heading-anchor" href="#user-guide-model-specification-data-variables">Data variables</a><a id="user-guide-model-specification-data-variables-1"></a><a class="docs-heading-anchor-permalink" href="#user-guide-model-specification-data-variables" title="Permalink"></a></h3><p>It is important to have a mechanism to pass data values to the model. You can create data inputs with <code>datavar()</code> function. As a first argument it accepts a type specification and optional dimensionality (as additional arguments or as a tuple).</p><p>Examples: </p><pre><code class="language-julia hljs">y = datavar(Float64) # Creates a single data input with `y` as identificator
y = datavar(Float64, n) # Returns a vector of  `y_i` data input objects with length `n`
y = datavar(Float64, n, m) # Returns a matrix of `y_i_j` data input objects with size `(n, m)`
y = datavar(Float64, (n, m)) # It is also possible to use a tuple for dimensionality, it is an equivalent of the previous line</code></pre><h3 id="Random-variables"><a class="docs-heading-anchor" href="#Random-variables">Random variables</a><a id="Random-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Random-variables" title="Permalink"></a></h3><p>There are several ways to create random variables. The first one is an explicit call to <code>randomvar()</code> function. By default it doesn&#39;t accept any argument, creates a single random variable in the model and returns it. It is also possible to pass dimensionality arguments to <code>randomvar()</code> function in the same way as for the <code>datavar()</code> function.</p><p>Examples: </p><pre><code class="language-julia hljs">x = randomvar() # Returns a single random variable which can be used later in the model
x = randomvar(n) # Returns an vector of random variables with length `n`
x = randomvar(n, m) # Returns a matrix of random variables with size `(n, m)`
x = randomvar((n, m)) # It is also possible to use a tuple for dimensionality, it is an equivalent of the previous line</code></pre><p>The second way to create a random variable is to use the <code>~</code> operator. If the random variable hasn&#39;t been created yet, <code>~</code> operator will be creat it automatically during the creation of the node. Read more about the <code>~</code> operator in the next section.</p><h2 id="Factor-nodes"><a class="docs-heading-anchor" href="#Factor-nodes">Factor nodes</a><a id="Factor-nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Factor-nodes" title="Permalink"></a></h2><p>Factor nodes (or local functions) are used to define a relationship between random variables and/or constants and data inputs. In most of the cases a factor node defines a probability distribution over selected random variables. </p><p>We model a random variable by a probability distribution using the <code>~</code> operator. For example, to create a random variable <code>y</code> which is modeled by a Normal distribution, where its mean and variance are controlled by the random variables <code>m</code> and <code>v</code> respectively, we define</p><pre><code class="language-julia hljs">m = randomvar()
v = randomvar()
y ~ NormalMeanVariance(m, v) # Creates a `y` random variable automatically</code></pre><p>It is also possible to use a deterministic relationships between random variables:</p><pre><code class="language-julia hljs">a = randomvar()
b = randomvar()
c ~ a + b # Here with the help of `~` operator we explictly say that `c` is a random variable too</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>GraphPPL.jl</code> package uses the <code>~</code> operator for modelling both stochastic and deterministic relationships between random variables.</p></div></div><p>The <code>@model</code> macro automatically resolves any inner function calls into anonymous extra nodes. It is also worth to note that inference backend will try to optimize inner deterministic function calls in the case where all arguments are constants or data inputs. For example:</p><pre><code class="language-julia hljs">noise ~ NormalMeanVariance(mean, inv(precision)) # Will create a non-linear node `inv` in case if `precision` is a random variable. Won&#39;t create an additional non-linear node in case if `precision` is a constant or data input.</code></pre><p>It is possible to use any functional expression within the <code>~</code> operator arguments list. The only one exception is the <code>ref</code> expression (e.g <code>x[i]</code> or <code>x[i, j]</code>). In principle <code>x[i]</code> expression is equivalent to <code>getindex(x, i)</code> and therefore might be treated as a factor node with <code>getindex</code> as local function, however all <code>ref</code> expressions within the <code>~</code> operator arguments list are left untouched during model parsing. This means that the model parser will not create unnecessary nodes when only simple indexing is involved.</p><pre><code class="language-julia hljs">y ~ NormalMeanVariance(x[i - 1], variance) # While in principle `x[i - 1]` is equivalent to (`getindex(x, -(i, 1))`) model parser will leave it untouched and won&#39;t create any anonymous nodes for this expression.

y ~ NormalMeanVariance(A * x[i - 1], variance) # This example will create a `*` anonymous node (in case if x[i - 1] is a random variable) and leave `x[i - 1]` untouched.</code></pre><p>It is also possible to return a node reference from the <code>~</code> operator with the following syntax:</p><pre><code class="language-julia hljs">node, y ~ NormalMeanVariance(mean, var)</code></pre><p>Having a node reference can be useful in case the user wants to return it from a model and to use it later on to specify initial joint marginal distributions.</p><h3 id="Node-creation-options"><a class="docs-heading-anchor" href="#Node-creation-options">Node creation options</a><a id="Node-creation-options-1"></a><a class="docs-heading-anchor-permalink" href="#Node-creation-options" title="Permalink"></a></h3><p>To pass optional arguments to the node creation constructor the user can use the <code>where { options...  }</code> specification syntax.</p><p>Example:</p><pre><code class="language-julia hljs">y ~ NormalMeanVariance(y_mean, y_var) where { q = q(y_mean)q(y_var)q(y) } # mean-field factorisation over q</code></pre><p>A list of all available options is presented below:</p><h4 id="Factorisation-constraint-option"><a class="docs-heading-anchor" href="#Factorisation-constraint-option">Factorisation constraint option</a><a id="Factorisation-constraint-option-1"></a><a class="docs-heading-anchor-permalink" href="#Factorisation-constraint-option" title="Permalink"></a></h4><p>Users can specify a factorisation constraint over the approximate posterior <code>q</code> for variational inference. The general syntax for factorisation constraints over <code>q</code> is the following:</p><pre><code class="language-julia hljs">variable ~ Node(node_arguments...) where { q = RecognitionFactorisationConstraint }</code></pre><p>where <code>RecognitionFactorisationConstraint</code> can be one the following:</p><ol><li><code>MeanField()</code></li></ol><p>Automatically specifies a mean-field factorisation</p><p>Example:</p><pre><code class="language-julia hljs">y ~ NormalMeanVariance(y_mean, y_var) where { q = MeanField() }</code></pre><ol><li><code>FullFactorisation()</code></li></ol><p>Automatically specifies a full factorisation (this is the default)</p><p>Example:</p><pre><code class="language-julia hljs">y ~ NormalMeanVariance(y_mean, y_var) where { q = FullFactorisation() }</code></pre><ol><li><code>q(μ)q(v)q(out)</code> or <code>q(μ) * q(v) * q(out)</code></li></ol><p>A user can specify any factorisation he wants as the multiplication of <code>q(interface_names...)</code> factors. As interface names the user can use the interface names of an actual node (read node&#39;s documentation), its aliases (if available) or actual random variable names present in the <code>~</code> operator expression.</p><p>Examples: </p><pre><code class="language-julia hljs"># Using interface names of a `NormalMeanVariance` node for factorisation constraint. 
# Call `?NormalMeanVariance` to know more about interface names for some node
y ~ NormalMeanVariance(y_mean, y_var) where { q = q(μ)q(v)q(out) }
y ~ NormalMeanVariance(y_mean, y_var) where { q = q(μ, v)q(out) }

# Using interface names aliases of a `NormalMeanVariance` node for factorisation constraint. 
# Call `?NormalMeanVariance` to know more about interface names aliases for some node
# In general aliases correspond to the function names for distribution parameters
y ~ NormalMeanVariance(y_mean, y_var) where { q = q(mean)q(var)q(out) }
y ~ NormalMeanVariance(y_mean, y_var) where { q = q(mean, var)q(out) }

# Using random variables names from `~` operator expression
y ~ NormalMeanVariance(y_mean, y_var) where { q = q(y_mean)q(y_var)q(y) }
y ~ NormalMeanVariance(y_mean, y_var) where { q = q(y_mean, y_var)q(y) }

# All methods can be combined easily
y ~ NormalMeanVariance(y_mean, y_var) where { q = q(μ)q(y_var)q(out) }
y ~ NormalMeanVariance(y_mean, y_var) where { q = q(y_mean, v)q(y) }</code></pre><h4 id="Metadata-option"><a class="docs-heading-anchor" href="#Metadata-option">Metadata option</a><a id="Metadata-option-1"></a><a class="docs-heading-anchor-permalink" href="#Metadata-option" title="Permalink"></a></h4><p>Is is possible to pass any extra metadata to a factor node with the <code>meta</code> option (if node supports it, read node&#39;s documentation). Metadata can be later accessed in message computation rules:</p><pre><code class="language-julia hljs">z ~ f(x, y) where { meta = ... }</code></pre><h4 id="Pipeline-option"><a class="docs-heading-anchor" href="#Pipeline-option">Pipeline option</a><a id="Pipeline-option-1"></a><a class="docs-heading-anchor-permalink" href="#Pipeline-option" title="Permalink"></a></h4><p>To assign a factor node&#39;s local pipeline we use a <code>pipeline</code> option:</p><pre><code class="language-julia hljs">y ~ NormalMeanVariance(m, v) where { pipeline = LoggerPipelineStage() } # Logs all outbound messages with `LoggerPipelineStage`</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../fundamentals/">« Fundamentals</a><a class="docs-footer-nextpage" href="../inference-execution/">Inference execution »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Friday 28 January 2022 13:26">Friday 28 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
