<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Model Specification · ReactiveMP.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ReactiveMP.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">User guide</span><ul><li><a class="tocitem" href="../getting-started/">Getting Started</a></li><li class="is-active"><a class="tocitem" href>Model Specification</a><ul class="internal"><li><a class="tocitem" href="#A-full-example-before-diving-in"><span>A full example before diving in</span></a></li><li><a class="tocitem" href="#Graph-variables-creation"><span>Graph variables creation</span></a></li><li><a class="tocitem" href="#Node-creation"><span>Node creation</span></a></li></ul></li><li><a class="tocitem" href="../constraints-specification/">Constraints Specification</a></li><li><a class="tocitem" href="../meta-specification/">Meta Specification</a></li><li><a class="tocitem" href="../inference-execution/">Inference execution</a></li><li><a class="tocitem" href="../advanced-tutorial/">Advanced Tutorial</a></li></ul></li><li><span class="tocitem">Custom functionality</span><ul><li><a class="tocitem" href="../../custom/custom-functional-form/">Custom functional form</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/message/">Messages</a></li><li><a class="tocitem" href="../../lib/form/">Functional forms</a></li><li><a class="tocitem" href="../../lib/prod/">Prod implementation</a></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Factor nodes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lib/node/">Overview</a></li><li><a class="tocitem" href="../../lib/nodes/flow/">Flow</a></li></ul></li><li><a class="tocitem" href="../../lib/math/">Math utils</a></li><li><a class="tocitem" href="../../lib/helpers/">Helper utils</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/overview/">Overview</a></li><li><a class="tocitem" href="../../examples/linear_regression/">Linear Regression</a></li><li><a class="tocitem" href="../../examples/linear_gaussian_state_space_model/">Linear Gaussian Dynamical System</a></li><li><a class="tocitem" href="../../examples/hidden_markov_model/">Hidden Markov Model</a></li><li><a class="tocitem" href="../../examples/hierarchical_gaussian_filter/">Hierarchical Gaussian Filter</a></li><li><a class="tocitem" href="../../examples/autoregressive/">Autoregressive Model</a></li><li><a class="tocitem" href="../../examples/flow_tutorial/">Normalizing Flows Tutorial</a></li><li><a class="tocitem" href="../../examples/univariate_normal_mixture/">Univariate Normal Mixture</a></li><li><a class="tocitem" href="../../examples/multivariate_normal_mixture/">Multivariate Normal Mixture</a></li><li><a class="tocitem" href="../../examples/gamma_mixture/">Gamma Mixture</a></li><li><a class="tocitem" href="../../examples/custom_nonlinear_node/">Custom Nonlinear Node</a></li><li><a class="tocitem" href="../../examples/missing_data/">Missing data</a></li></ul></li><li><a class="tocitem" href="../../extra/contributing/">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User guide</a></li><li class="is-active"><a href>Model Specification</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Model Specification</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/biaslab/ReactiveMP.jl/blob/master/docs/src/man/model-specification.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="user-guide-model-specification"><a class="docs-heading-anchor" href="#user-guide-model-specification">Model Specification</a><a id="user-guide-model-specification-1"></a><a class="docs-heading-anchor-permalink" href="#user-guide-model-specification" title="Permalink"></a></h1><p>The <code>GraphPPL.jl</code> package exports the <code>@model</code> macro for model specification. This <code>@model</code> macro accepts two arguments: model options and the model specification itself in a form of regular Julia function. For example: </p><pre><code class="language-julia hljs">@model [ option1 = ..., option2 = ... ] function model_name(model_arguments...; model_keyword_arguments...)
    # model specification here
    return ...
end</code></pre><p>Model options, <code>model_arguments</code> and <code>model_keyword_arguments</code> are optional and may be omitted:</p><pre><code class="language-julia hljs">@model function model_name()
    # model specification here
    return ...
end</code></pre><p>The <code>@model</code> macro returns a regular Julia function (in this example <code>model_name()</code>) which can be executed as usual. It returns a reference to a model object itself and a tuple of a user specified return variables, e.g:</p><pre><code class="language-julia hljs">@model function my_model(model_arguments...)
    # model specification here
    # ...
    return x, y
end</code></pre><pre><code class="language-julia hljs">model, (x, y) = my_model(model_arguments...)</code></pre><p>It is not necessary to return anything from the model, in that case <code>GraphPPL.jl</code> will automatically inject <code>return nothing</code> to the end of the model function.</p><h2 id="A-full-example-before-diving-in"><a class="docs-heading-anchor" href="#A-full-example-before-diving-in">A full example before diving in</a><a id="A-full-example-before-diving-in-1"></a><a class="docs-heading-anchor-permalink" href="#A-full-example-before-diving-in" title="Permalink"></a></h2><p>Before presenting the details of the model specification syntax, an example of a probabilistic model is given. Here is an example of a simple state space model with latent random variables <code>x</code> and noisy observations <code>y</code>:</p><pre><code class="language-julia hljs">@model [ options... ] function state_space_model(n_observations, noise_variance)

    c = constvar(1.0)
    x = randomvar(n_observations)
    y = datavar(Float64, n_observations)

    x[1] ~ NormalMeanVariance(0.0, 100.0)

    for i in 2:n_observations
       x[i] ~ x[i - 1] + c
       y[i] ~ NormalMeanVariance(x[i], noise_var)
    end

    return x, y
end</code></pre><h2 id="Graph-variables-creation"><a class="docs-heading-anchor" href="#Graph-variables-creation">Graph variables creation</a><a id="Graph-variables-creation-1"></a><a class="docs-heading-anchor-permalink" href="#Graph-variables-creation" title="Permalink"></a></h2><h3 id="user-guide-model-specification-constant-variables"><a class="docs-heading-anchor" href="#user-guide-model-specification-constant-variables">Constants</a><a id="user-guide-model-specification-constant-variables-1"></a><a class="docs-heading-anchor-permalink" href="#user-guide-model-specification-constant-variables" title="Permalink"></a></h3><p>Any runtime constant passed to a model as a model argument will be automatically converted to a fixed constant in the graph model at runtime. Sometimes it might be useful to create constants by hand (e.g. to avoid copying large matrices across the model and to avoid extensive memory allocations).</p><p>You can create a constant within a model specification macro with <code>constvar()</code> function. For example:</p><pre><code class="language-julia hljs">c = constvar(1.0)

for i in 2:n
    x[i] ~ x[i - 1] + c # Reuse the same reference to a constant 1.0
end</code></pre><p>Additionally you can specify an extra <code>::ConstVariable</code> type for some of the model arguments. In this case macro automatically converts them to a single constant using <code>constvar()</code> function. E.g.:</p><pre><code class="language-julia hljs">@model function model_name(nsamples::Int, c::ConstVariable)
    # ...
    # no need to call for a constvar() here
    for i in 2:n
        x[i] ~ x[i - 1] + c # Reuse the same reference to a constant `c`
    end
    # ...
    return ...
end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>::ConstVariable</code> annotation does not play role in Julia&#39;s multiple dispatch. <code>GraphPPL.jl</code> removes this annotation and replaces it with <code>::Any</code>.</p></div></div><h3 id="user-guide-model-specification-data-variables"><a class="docs-heading-anchor" href="#user-guide-model-specification-data-variables">Data variables</a><a id="user-guide-model-specification-data-variables-1"></a><a class="docs-heading-anchor-permalink" href="#user-guide-model-specification-data-variables" title="Permalink"></a></h3><p>It is important to have a mechanism to pass data values to the model. You can create data inputs with <code>datavar()</code> function. As a first argument it accepts a type specification and optional dimensionality (as additional arguments or as a tuple). User can treat <code>datavar()</code>s in the model as both clamped values for priors and observations.</p><p>Examples: </p><pre><code class="language-julia hljs">y = datavar(Float64) # Creates a single data input with `y` as identificator
y = datavar(Float64, n) # Returns a vector of  `y_i` data input objects with length `n`
y = datavar(Float64, n, m) # Returns a matrix of `y_i_j` data input objects with size `(n, m)`
y = datavar(Float64, (n, m)) # It is also possible to use a tuple for dimensionality</code></pre><p><code>datavar()</code> call supports <code>where { options... }</code> block for extra options specification. </p><h4 id="Data-variables-available-options"><a class="docs-heading-anchor" href="#Data-variables-available-options">Data variables available options</a><a id="Data-variables-available-options-1"></a><a class="docs-heading-anchor-permalink" href="#Data-variables-available-options" title="Permalink"></a></h4><ul><li><code>allow_missing = true/false</code>: Specifies if it is possible to pass <code>missing</code> object as an observation. Note however that by default ReactiveMP.jl does not expose any message computation rules that involve <code>missing</code>s.</li></ul><h3 id="user-guide-model-specification-random-variables"><a class="docs-heading-anchor" href="#user-guide-model-specification-random-variables">Random variables</a><a id="user-guide-model-specification-random-variables-1"></a><a class="docs-heading-anchor-permalink" href="#user-guide-model-specification-random-variables" title="Permalink"></a></h3><p>There are several ways to create random variables. The first one is an explicit call to <code>randomvar()</code> function. By default it doesn&#39;t accept any argument, creates a single random variable in the model and returns it. It is also possible to pass dimensionality arguments to <code>randomvar()</code> function in the same way as for the <code>datavar()</code> function.</p><p>Examples: </p><pre><code class="language-julia hljs">x = randomvar() # Returns a single random variable which can be used later in the model
x = randomvar(n) # Returns an vector of random variables with length `n`
x = randomvar(n, m) # Returns a matrix of random variables with size `(n, m)`
x = randomvar((n, m)) # It is also possible to use a tuple for dimensionality</code></pre><p>In the same way as <code>datavar()</code> function, <code>randomvar()</code> options supports <code>where { options... }</code> block for exxtra options. </p><h4 id="Random-variables-available-options"><a class="docs-heading-anchor" href="#Random-variables-available-options">Random variables available options</a><a id="Random-variables-available-options-1"></a><a class="docs-heading-anchor-permalink" href="#Random-variables-available-options" title="Permalink"></a></h4><ul><li><code>prod_constraint</code></li><li><code>prod_strategy</code></li><li><code>marginal_form_constraint</code></li><li><code>marginal_form_check_strategy</code></li><li><code>messages_form_constraint</code></li><li><code>messages_form_check_strategy</code></li><li><code>pipeline</code></li></ul><p>The second way to create a random variable is to create a node with the <code>~</code> operator. If the random variable has not yet been created before this call, it will be created automatically during the creation of the node. Read more about the <code>~</code> operator below.</p><h2 id="Node-creation"><a class="docs-heading-anchor" href="#Node-creation">Node creation</a><a id="Node-creation-1"></a><a class="docs-heading-anchor-permalink" href="#Node-creation" title="Permalink"></a></h2><p>Factor nodes are used to define a relationship between random variables and/or constants and data inputs. A factor node defines a probability distribution over selected random variables. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To quickly check the list of all available factor nodes that can be used in the model specification language call <code>?make_node</code> or <code>Base.doc(make_node)</code>.</p></div></div><p>We model a random variable by a probability distribution using the <code>~</code> operator. For example, to create a random variable <code>y</code> which is modeled by a Normal distribution, where its mean and variance are controlled by the random variables <code>m</code> and <code>v</code> respectively, we define</p><pre><code class="language-julia hljs">m = randomvar()
v = randomvar()
y ~ NormalMeanVariance(m, v) # Creates a `y` random variable automatically</code></pre><p>Another example, but using a determnistic relation between random variables:</p><pre><code class="language-julia hljs">a = randomvar()
b = randomvar()
c ~ a + b</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>GraphPPL.jl</code> package uses the <code>~</code> operator for modelling both stochastic and deterministic relationships between random variables.</p></div></div><p>The <code>@model</code> macro automatically resolves any inner function calls into anonymous extra nodes in case this inner function call is a non-linear transformations. It will also create needed anonymous random variables. But it is important to note that the inference backend will try to optimize inner non-linear deterministic function calls in the case where all arguments are constants or data inputs. For example:</p><pre><code class="language-julia hljs">noise ~ NormalMeanVariance(mean, inv(precision)) # Will create a non-linear `inv` node in case if `precision` is a random variable. Won&#39;t create an additional non-linear node in case if `precision` is a constant or data input.</code></pre><p>It is possible to use any functional expression within the <code>~</code> operator arguments list. The only one exception is the <code>ref</code> expression (e.g <code>x[i]</code>). All reference expressions within the <code>~</code> operator arguments list are left untouched during model parsing. This means that the model parser will not create unnecessary nodes when only simple indexing is involved.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is forbidden to use random variable within square brackets in the model specification.</p></div></div><pre><code class="language-julia hljs">y ~ NormalMeanVariance(x[i - 1], variance) # While in principle `i - 1` is an inner function call (`-(i, 1)`) model parser will leave it untouched and won&#39;t create any anonymous nodes for `ref` expressions.

y ~ NormalMeanVariance(A * x[i - 1], variance) # This example will create a `*` anonymous node (in case if x[i - 1] is a random variable) and leave `x[i - 1]` untouched.</code></pre><p>It is also possible to return a node reference from the <code>~</code> operator. Use the following syntax:</p><pre><code class="language-julia hljs">node, y ~ NormalMeanVariance(mean, var)</code></pre><p>Having a node reference can be useful in case the user wants to return it from a model and to use it later on to specify initial joint marginal distributions.</p><h3 id="Node-creation-options"><a class="docs-heading-anchor" href="#Node-creation-options">Node creation options</a><a id="Node-creation-options-1"></a><a class="docs-heading-anchor-permalink" href="#Node-creation-options" title="Permalink"></a></h3><p>To pass optional arguments to the node creation constructor the user can use the <code>where { options...  }</code> options specification syntax.</p><p>Example:</p><pre><code class="language-julia hljs">y ~ NormalMeanVariance(y_mean, y_var) where { q = q(y_mean)q(y_var)q(y) } # mean-field factorisation over q</code></pre><p>A list of the available options specific to <code>ReactiveMP.jl</code> is presented below.</p><h4 id="Factorisation-constraint-option"><a class="docs-heading-anchor" href="#Factorisation-constraint-option">Factorisation constraint option</a><a id="Factorisation-constraint-option-1"></a><a class="docs-heading-anchor-permalink" href="#Factorisation-constraint-option" title="Permalink"></a></h4><p>See also <a href="../constraints-specification/#user-guide-constraints-specification">Constraints Specification</a> section.</p><p>Users can specify a factorisation constraint over the approximate posterior <code>q</code> for variational inference. The general syntax for factorisation constraints over <code>q</code> is the following:</p><pre><code class="language-julia hljs">variable ~ Node(node_arguments...) where { q = RecognitionFactorisationConstraint }</code></pre><p>where <code>RecognitionFactorisationConstraint</code> can be the following</p><ol><li><code>MeanField()</code></li></ol><p>Automatically specifies a mean-field factorisation</p><p>Example:</p><pre><code class="language-julia hljs">y ~ NormalMeanVariance(y_mean, y_var) where { q = MeanField() }</code></pre><ol><li><code>FullFactorisation()</code></li></ol><p>Automatically specifies a full factorisation</p><p>Example:</p><pre><code class="language-julia hljs">y ~ NormalMeanVariance(y_mean, y_var) where { q = FullFactorisation() }</code></pre><ol><li><code>q(μ)q(v)q(out)</code> or <code>q(μ) * q(v) * q(out)</code></li></ol><p>A user can specify any factorisation he wants as the multiplication of <code>q(interface_names...)</code> factors. As interface names the user can use the interface names of an actual node (read node&#39;s documentation), its aliases (if available) or actual random variable names present in the <code>~</code> operator expression.</p><p>Examples: </p><pre><code class="language-julia hljs"># Using interface names of a `NormalMeanVariance` node for factorisation constraint. 
# Call `?NormalMeanVariance` to know more about interface names for some node
y ~ NormalMeanVariance(y_mean, y_var) where { q = q(μ)q(v)q(out) }
y ~ NormalMeanVariance(y_mean, y_var) where { q = q(μ, v)q(out) }

# Using interface names aliases of a `NormalMeanVariance` node for factorisation constraint. 
# Call `?NormalMeanVariance` to know more about interface names aliases for some node
# In general aliases correspond to the function names for distribution parameters
y ~ NormalMeanVariance(y_mean, y_var) where { q = q(mean)q(var)q(out) }
y ~ NormalMeanVariance(y_mean, y_var) where { q = q(mean, var)q(out) }

# Using random variables names from `~` operator expression
y ~ NormalMeanVariance(y_mean, y_var) where { q = q(y_mean)q(y_var)q(y) }
y ~ NormalMeanVariance(y_mean, y_var) where { q = q(y_mean, y_var)q(y) }

# All methods can be combined easily
y ~ NormalMeanVariance(y_mean, y_var) where { q = q(μ)q(y_var)q(out) }
y ~ NormalMeanVariance(y_mean, y_var) where { q = q(y_mean, v)q(y) }</code></pre><h4 id="Metadata-option"><a class="docs-heading-anchor" href="#Metadata-option">Metadata option</a><a id="Metadata-option-1"></a><a class="docs-heading-anchor-permalink" href="#Metadata-option" title="Permalink"></a></h4><p>Is is possible to pass any extra metadata to a factor node with the <code>meta</code> option. Metadata can be later accessed in message computation rules. See also <a href="../meta-specification/#user-guide-meta-specification">Meta specification</a> section.</p><pre><code class="language-julia hljs">z ~ f(x, y) where { meta = ... }</code></pre><h4 id="Pipeline-option"><a class="docs-heading-anchor" href="#Pipeline-option">Pipeline option</a><a id="Pipeline-option-1"></a><a class="docs-heading-anchor-permalink" href="#Pipeline-option" title="Permalink"></a></h4><p>WIP</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting-started/">« Getting Started</a><a class="docs-footer-nextpage" href="../constraints-specification/">Constraints Specification »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.16 on <span class="colophon-date" title="Tuesday 26 April 2022 14:26">Tuesday 26 April 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
